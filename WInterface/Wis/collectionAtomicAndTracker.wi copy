






TrackerMutableSet :NSMutableSet<TrackerMutableSet>


<TrackerMutableSet:MutableSet>
    NSMutableSet atomicSet (nodef,ivar=atomicSet)

    -(void)commitAtomicSet {
        if ([atomicSet respondsToSelector:@selector(__commitSetSet:)]) {
            [(AtomiclyMutableSet*)atomicSet __commitSetSet:self];
            ((AtomiclyMutableSet*)atomicSet).version=version;
        }
        else [atomicSet setSet:self];
    }






AtomiclyMutableSet:NSMutableSet<Set,Commitable,ObjectEquate>
    long version=1

    ModelMutableSet __mutableSet (nodef,readonly,ivar=__mutableSet)
    NSMutableSet<TrackerMutableSet> trackerSet (nodef,ivar=trackerSet)

    -(void)__commitSetSet:(NSSet*)Set {
        [__mutableSet setSet:Set];
        version++;
    }

    //Creating a Mutable Set
    +(id)SetWithCapacity:(NSUInteger)numItems {
        return([[[__WIClass__ alloc] initWithCapacity:numItems] autorelease]);
    }
    -(init)init {
        /*!-100*/__set=__mutableSet=[[ModelMutableSet alloc] init];
    }
    -(init[super init])initWithCoder:(NSCoder*)coder {
        /*!-100*/__set=__mutableSet=[[ModelMutableSet alloc] initWithCoder:coder];
    }
    -(init[super init])initWithArray:(NSArray*)array {
        /*!-100*/__set=__mutableSet=[[ModelMutableSet alloc] initWithArray:array];
    }
    -(init[super init])initWithObjects:(id*)objects count:(NSUInteger)count {
        /*!-100*/__set=__mutableSet=[[ModelMutableSet alloc] initWithObjects:objects count:count];
    }
    -(init[super init])initWithSet:(NSSet*)set {
        /*!-100*/__set=__mutableSet=[[ModelMutableSet alloc] initWithSet:set];
    }
    -(init[super init])initWithSet:(NSSet*)set copyItems:(BOOL)copy {
        /*!-100*/__set=__mutableSet=[[ModelMutableSet alloc] initWithSet:set copyItems:copy];
    }
    -(init[super init])initWithCapacity:(NSUInteger)numItems {
        /*-100*/__set=__mutableSet=[[ModelMutableSet alloc] initWithCapacity:numItems];
    }
    


    -(void)addObject:(id)object {
        [trackerSet addObject:object];
        if (trackerSet.version!=version) [self markDirty];
    }
    -(void)filterUsingPredicate:(NSPredicate *)predicate {
        [trackerSet filterUsingPredicate:predicate];
        if (trackerSet.version!=version) [self markDirty];
    }
    -(void)removeObject:(id)object {
        [trackerSet removeObject:object];
        if (trackerSet.version!=version) [self markDirty];
    }
    -(void)removeAllObjects {
        [trackerSet removeAllObjects];
        if (trackerSet.version!=version) [self markDirty];
    }
    -(void)addObjectsFromArray:(NSArray*)array {
        [trackerSet addObjectsFromArray:array];
        if (trackerSet.version!=version) [self markDirty];
    }
    -(void)unionSet:(NSSet*)set {
        [trackerSet unionSet:set];
        if (trackerSet.version!=version) [self markDirty];
    }
    -(void)minusSet:(NSSet*)set {
        [trackerSet minusSet:set];
        if (trackerSet.version!=version) [self markDirty];
    }
    -(void)intersectSet:(NSSet*)set {
        [trackerSet intersectSet:set];
        if (trackerSet.version!=version) [self markDirty];
    }
    -(void)setSet:(NSSet*)set {
        [trackerSet setSet:set];
        if (trackerSet.version!=version) [self markDirty];
    }


    




























TrackerMutableDictionary :NSMutableDictionary<TrackerMutableDictionary>


<TrackerMutableDictionary:MutableDictionary>
    NSMutableDictionary atomicDictionary (nodef,ivar=atomicDictionary)

    -(void)commitAtomicDictionary {
        if ([atomicDictionary respondsToSelector:@selector(__commitSetDictionary:)]) {
            [(AtomiclyMutableDictionary*)atomicDictionary __commitSetDictionary:self];
            ((AtomiclyMutableDictionary*)atomicDictionary).version=version;
        }
        else [atomicDictionary setDictionary:self];
    }







AtomiclyMutableDictionary:NSMutableDictionary<Dictionary,Commitable,ObjectEquate>
    long version=1

    ModelMutableDictionary __mutableDictionary (nodef,readonly,ivar=__mutableDictionary)
    NSMutableDictionary<TrackerMutableDictionary> trackerDictionary (nodef,ivar=trackerDictionary)

    -(void)__commitSetDictionary:(NSDictionary*)Dictionary {
        [__mutableDictionary setDictionary:Dictionary];
        version++;
    }

    //Creating a Mutable Dictionary
    +(id)DictionaryWithCapacity:(NSUInteger)numItems {
        return([[[__WIClass__ alloc] initWithCapacity:numItems] autorelease]);
    }
    -(init)init {
        /*!-100*/__dictionary=__mutableDictionary=[[ModelMutableDictionary alloc] init];
    }
    -(init[super init])initWithCoder:(NSCoder*)coder {
        /*!-100*/__dictionary=__mutableDictionary=[[ModelMutableDictionary alloc] initWithCoder:coder];
    }
    -(init[super init])initWithContentsOfFile:(NSString*)file {
        /*!-100*/__dictionary=__mutableDictionary=[[ModelMutableDictionary alloc] initWithContentsOfFile:file];
    }
    -(init[super init])initWithContentsOfURL:(NSURL*)url {
        /*!-100*/__dictionary=__mutableDictionary=[[ModelMutableDictionary alloc] initWithContentsOfURL:url];
    }
    -(init[super init])initWithDictionary:(NSDictionary*)dictionary {
        /*!-100*/__dictionary=__mutableDictionary=[[ModelMutableDictionary alloc] initWithDictionary:dictionary];
    }
    -(init[super init])initWithDictionary:(NSDictionary*)dictionary copyItems:(BOOL)copy {
        /*!-100*/__dictionary=__mutableDictionary=[[ModelMutableDictionary alloc] initWithDictionary:dictionary copyItems:copy];
    }
    -(init[super init])initWithObjects:(const id[])objects forKeys:(const id<NSCopying>[])keys count:(NSUInteger)count {
        /*!-100*/__dictionary=__mutableDictionary=[[ModelMutableDictionary alloc] initWithObjects:objects forKeys:keys count:count];
    }
    -(init[super init])initWithCapacity:(NSUInteger)numItems {
        /*-100*/__dictionary=__mutableDictionary=[[ModelMutableDictionary alloc] initWithCapacity:numItems];
    }
    

    -(void)setObject:(id)object forKey:(id<NSCopying>)key {
        [trackerDictionary setObject:object forKey:key];
        if (trackerDictionary.version!=version) [self markDirty];
    }
    -(void)removeObjectForKey:(id<NSCopying>)key {
        if ([self objectForKey:key]) {
            [trackerDictionary removeObjectForKey:key];
            if (trackerDictionary.version!=version) [self markDirty];
        }
    }
    -(void)setValue:(id)object forKey:(NSString*)key {
        [trackerDictionary setValue:object forKey:key];
        if (trackerDictionary.version!=version) [self markDirty];
    }
    -(void)addEntriesFromDictionary:(NSDictionary*)dictionary {
        [trackerDictionary addEntriesFromDictionary:dictionary];
        if (trackerDictionary.version!=version) [self markDirty];
    }
    -(void)setDictionary:(NSDictionary*)dictionary {
        [trackerDictionary setDictionary:dictionary];
        if (trackerDictionary.version!=version) [self markDirty];
    }
    -(void)removeAllObjects {
        [trackerDictionary removeAllObjects];
        if (trackerDictionary.version!=version) [self markDirty];
    }
    -(void)removeObjectsForKeys:(NSArray*)keys {
        [trackerDictionary removeObjectsForKeys:keys];
        if (trackerDictionary.version!=version) [self markDirty];
    }
    
    
    
    
    
    





















TrackerMutableArray :NSMutableArray<TrackerMutableArray>

<TrackerMutableArray:MinimalMutableArray>
    NSMutableArray atomicArray (nodef,ivar=atomicArray)
    IndexToIndexMap indexToIndexMap=[[[IndexToIndexMap alloc] init] autorelease] (ivar=indexToIndexMap)
    NSMutableDictionary deletedObjectMap=[NSMutableDictionary dictionary] (ivar=deletedObjectMap)
    bool mappingIsValid=1

    -(void)didAddObject:(id)object withIndex:(NSUInteger)index {
        if (!mappingIsValid) return;
        NSMutableIndexSet *s=[deletedObjectMap objectForKey:object];
        NSUInteger bi=NSNotFound;
        if (!s) {
            if (!atomicArray) {
                NSLog(@"Please set atomicArray");
                return;
            }
            for (bi=[atomicArray indexOfObjectIdenticalTo:object];bi!=NSNotFound;bi=[atomicArray indexOfObjectIdenticalTo:object inRange:NSMakeRange(bi+1,__array.count-bi)]) {
                if (![indexToIndexMap.bValidIndexes containsIndex:bi]) break;
            }
        }
        else {
            bi=s.firstIndex;
            if (s.count==1) [deletedObjectMap removeObjectForKey:object];
            else [s removeIndex:bi];
        }
        if (bi!=NSNotFound) {
            [indexToIndexMap shiftAIndexesFromIndex:index by:1];
            [indexToIndexMap addAIndex:index withBIndex:bi];
        }
        else mappingIsValid=NO;
    }
    -(void)didAddObject:(id)object {
        mappingIsValid=NO;
    }
    -(void)willRemoveObject:(id)object fromIndex:(NSUInteger)index {
        if (!mappingIsValid) return;
        NSUInteger bi=[indexToIndexMap bIndexForAIndex:index];
        [indexToIndexMap removeAIndex:index];
        if (bi!=NSNotFound) {
            NSMutableIndexSet *s=[deletedObjectMap objectForKey:object];
            if (s) [s addIndex:bi];
            else [deletedObjectMap setObject:[NSMutableIndexSet indexSetWithIndex:bi] forWeakKey:object];
        }            
    }
    -(void)willRemoveObject:(id)object {
        mappingIsValid=NO;
    }
    -(void)objectsSwappedWithIndex:(NSUInteger)fromIndex andIndex:(NSUInteger)toIndex {
        if (!mappingIsValid) return;
        [indexToIndexMap swapBIndexesForAIndex:fromIndex andAIndex:toIndex];
    }
    -(void)objectsMovedFromRange:(NSRange)fromRange toLocation:(NSUInteger)toLocation {
        if (!mappingIsValid) return;
        [indexToIndexMap shiftAIndexesInRange:fromRange by:((int)toLocation)-((int)fromRange.location)];
    }
    -(void)allObjectsMoved {
        mappingIsValid=NO;
    }
    -(void)commitAtomicArray {
        [deletedObjectMap removeAllObjects];
        [indexToIndexMap setIdentityWithCount:self.count];
        if ([atomicArray respondsToSelector:@selector(__commitSetArray:)]) {
            [(AtomiclyMutableArray*)atomicArray __commitSetArray:self];
            ((AtomiclyMutableArray*)atomicArray).version=version;
        }
        else [atomicArray setArray:self];
        self.mappingIsValid=1;
    }
    -(NSUInteger)atomicArrayIndexForObjectAtIndex:(NSUInteger)ai {
        return(mappingIsValid?[indexToIndexMap bIndexForAIndex:ai]:NSNotFound);
    }
    -(NSUInteger)objectIndexForObjectAtIndexInAtomicArray:(NSUInteger)bi {
        return(mappingIsValid?[indexToIndexMap aIndexForBIndex:bi]:NSNotFound);
    }





AtomiclyMutableArray:NSMutableArray<Array,Commitable,ObjectEquate>
    long version=1

    ModelMutableArray __mutableArray (nodef,readonly,ivar=__mutableArray)
    NSMutableArray<TrackerMutableArray> trackerArray (nodef,ivar=trackerArray)

    -(void)__commitSetArray:(NSArray*)array {
        [__mutableArray setArray:array];
        version++;
    }

    //Creating a Mutable Array
    +(id)arrayWithCapacity:(NSUInteger)numItems {
        return([[[__WIClass__ alloc] initWithCapacity:numItems] autorelease]);
    }
    -(init)init {/*!-100*/__array=__mutableArray=[[ModelMutableArray alloc] init];
    }
    -(init[super init])initWithCoder:(NSCoder*)coder {
        /*!-100*/__array=__mutableArray=[[ModelMutableArray alloc] initWithCoder:coder];
    }
    -(init[super init])initWithArray:(NSArray*)array {
        /*!-100*/__array=__mutableArray=[[ModelMutableArray alloc] initWithArray:array];
    }
    -(init[super init])initWithArray:(NSArray*)array copyItems:(BOOL)copy {
        /*!-100*/__array=__mutableArray=[[ModelMutableArray alloc] initWithArray:array copyItems:copy];
    }
    -(init[super init])initWithContentsOfFile:(NSString*)file {
        /*!-100*/__array=__mutableArray=[[ModelMutableArray alloc] initWithContentsOfFile:file];
    }
    -(init[super init])initWithContentsOfURL:(NSURL*)url {
        /*!-100*/__array=__mutableArray=[[ModelMutableArray alloc] initWithContentsOfURL:url];
    }
    -(init[super init])initWithObjects:(id*)objects count:(NSUInteger)count {
        /*!-100*/__array=__mutableArray=[[ModelMutableArray alloc] initWithObjects:objects count:count];
    }
    -(init[super init])initWithCapacity:(NSUInteger)numItems {
        /*-100*/__array=__mutableArray=[[ModelMutableArray alloc] initWithCapacity:numItems];
    }
    
    
    //Adding Objects
    -(void)addObject:(id)object {
        [trackerArray addObject:object];
        if (trackerArray.version!=version) [self markDirty];
    }
    -(void)insertObject:(id)object atIndex:(NSUInteger)index {
        NSUInteger ai=NSNotFound;
        while (index>0) {
            ai=[trackerArray objectIndexForObjectAtIndexInAtomicArray:index-1];
            if (ai!=NSNotFound) break;
            index--;
        }
        [trackerArray insertObject:object atIndex:(ai==NSNotFound?0:(ai+1))];
        if (trackerArray.version!=version) [self markDirty];
    }
    -(void)removeObjectAtIndex:(NSUInteger)index {
        NSUInteger ai=[trackerArray objectIndexForObjectAtIndexInAtomicArray:index];
        if (ai!=NSNotFound) {
            [trackerArray removeObjectAtIndex:ai];
            if (trackerArray.version!=version) [self markDirty];
        }
    }
    -(void)removeLastObject {
        if (self.count) {
            [self removeObjectAtIndex:self.count-1];
            if (trackerArray.version!=version) [self markDirty];
        }
    }
    -(void)replaceObjectAtIndex:(NSUInteger)index withObject:(id)object {
        NSUInteger ai=[trackerArray objectIndexForObjectAtIndexInAtomicArray:index];
        if (ai!=NSNotFound) {
            [trackerArray replaceObjectAtIndex:ai withObject:object];
            if (trackerArray.version!=version) [self markDirty];
        }
    }

    -(void)addObjectsFromArray:(NSArray*)array {
        for (id object in array) [self addObject:object];
    }

    -(void)insertObjects:(NSArray*)objects atIndexes:(NSIndexSet*)indexes {
        NSUInteger index=[indexes firstIndex];
        for (id object in objects) {
           [self insertObject:object atIndex:index];
            index=[indexes indexGreaterThanIndex:index];
        }
    }
    
    
    //Removing Objects
    -(void)removeAllObjects {
        [trackerArray removeAllObjects];
        if (trackerArray.version!=version) [self markDirty];
    }
    -(void)removeObject:(id)object {
        for (NSUInteger index=[self indexOfObject:object];index!=NSNotFound;index=[self indexOfObject:object inRange:NSMakeRange(index+1,self.count-(index+1))]) {
            [self removeObjectAtIndex:index];
        }
    }
    -(void)removeObject:(id)object inRange:(NSRange)r {
        for (NSUInteger index=[self indexOfObject:object inRange:r];index!=NSNotFound;index=[self indexOfObject:object inRange:NSMakeRange(index+1,(r.location+r.length)-(index+1))]) {
            [self removeObjectAtIndex:index];
        }
    }

    -(void)removeObjectsAtIndexes:(NSIndexSet*)indexes {
        for (NSUInteger index=[indexes firstIndex];index!=NSNotFound;index=[indexes indexGreaterThanIndex:index]) {
            [self removeObjectAtIndex:index];
        }
    }
    -(void)removeObjectIdenticalTo:(id)object {
        for (NSUInteger index=[self indexOfObjectIdenticalTo:object];index!=NSNotFound;index=[self indexOfObjectIdenticalTo:object inRange:NSMakeRange(index+1,self.count-(index+1))]) {
            [self removeObjectAtIndex:index];
        }
    }
    -(void)removeObjectIdenticalTo:(id)object inRange:(NSRange)r {
        for (NSUInteger index=[self indexOfObjectIdenticalTo:object inRange:r];index!=NSNotFound;index=[self indexOfObjectIdenticalTo:object inRange:NSMakeRange(index+1,(r.location+r.length)-(index+1))]) {
            [self removeObjectAtIndex:index];
        }
    }
    -(void)removeObjectsInArray:(NSArray*)array {
        for (id object in array) [self removeObject:object];
    }
    -(void)removeObjectsInRange:(NSRange)r {
        for (NSUInteger i=r.location;i<r.location+r.length;i++) {
            [self removeObjectAtIndex:i];
        }
    }
    
    
    //Replacing Objects
    -(void)replaceObjectsAtIndexes:(NSIndexSet*)indexes withObjects:(NSArray*)array {
        NSUInteger index=[indexes firstIndex];
        for (id object in array) {
            [self replaceObjectAtIndex:index withObject:object];
            index=[indexes indexGreaterThanIndex:index];
        }
    }
    -(void)replaceObjectsInRange:(NSRange)r withObjectsFromArray:(NSArray*)array range:(NSRange)arrayRange {
        for (int i=0;i<MIN(r.length,arrayRange.length);i++) {
            [self replaceObjectAtIndex:i+r.location withObject:[array objectAtIndex:i+arrayRange.location]];
        }
        for (NSUInteger i=arrayRange.length;i<r.length;i++) [self removeObjectAtIndex:i+r.location];
        for (NSUInteger i=arrayRange.length-1;i>=r.length;i--) [self insertObject:[array objectAtIndex:i] atIndex:r.location+r.length+1];
    }
    -(void)replaceObjectsInRange:(NSRange)r withObjectsFromArray:(NSArray*)array {
        [self replaceObjectsInRange:r withObjectsFromArray:array range:NSMakeRange(0,array.count)];
    }
    -(void)setArray:(NSArray*)array {
        [trackerArray setArray:array];
        if (trackerArray.version!=version) [self markDirty];
    }
    
    
    //Filtering Content
    -(void)filterUsingPredicate:(NSPredicate *)predicate {
        NSMutableIndexSet *toRemove=nil;
        NSUInteger index=0;
        for (id object in __array) {
            if (![predicate evaluateWithObject:object]) {
                if (!toRemove) toRemove=[[NSMutableIndexSet alloc] init];
                [toRemove addIndex:index];
            }
            index++;
        }
        if (toRemove) {
            [self removeObjectsAtIndexes:toRemove];
            [toRemove release];
        }
    }
    
    
    //Rearranging Content
    -(void)exchangeObjectAtIndex:(NSUInteger)fromi withObjectAtIndex:(NSUInteger)toi {
        if (fromi!=toi) {
            NSUInteger fromai=[trackerArray objectIndexForObjectAtIndexInAtomicArray:fromi];
            NSUInteger toai=[trackerArray objectIndexForObjectAtIndexInAtomicArray:toi];
            [trackerArray exchangeObjectAtIndex:fromai withObjectAtIndex:toai];
            if (trackerArray.version!=version) [self markDirty];
        }
    }
    -(void)sortUsingDescriptors:(NSArray*)sortDescriptors {
        [trackerArray sortUsingDescriptors:sortDescriptors];
        if (trackerArray.version!=version) [self markDirty];
    }
    -(void)sortUsingComparator:(NSComparator)cmptr {
        [trackerArray sortUsingComparator:cmptr];
        if (trackerArray.version!=version) [self markDirty];
    }
    -(void)sortWithOptions:(NSSortOptions)opts usingComparator:(NSComparator)cmptr {
        [trackerArray sortWithOptions:opts usingComparator:cmptr];
        if (trackerArray.version!=version) [self markDirty];
    }
    -(void)sortUsingFunction:(NSInteger (*)(id, id, void *))compare context:(void *)context {
        [trackerArray sortUsingFunction:compare context:context];
        if (trackerArray.version!=version) [self markDirty];
    }
    -(void)sortUsingSelector:(SEL)selector {
        [trackerArray sortUsingSelector:selector];
        if (trackerArray.version!=version) [self markDirty];
    }












IndexToIndexMap
    NSMutableIndexSet aValidIndexes=[NSMutableIndexSet indexSet] (ivar=aValidIndexes)
    NSMutableIndexSet bValidIndexes=[NSMutableIndexSet indexSet] (ivar=bValidIndexes)
    NSMutableArray atobMap=[NSMutableArray array] (ivar=atobMap)


    -(init)init {
    }

    -(NSUInteger)aIndexForBIndex:(NSUInteger)bi {
        if ((bi==NSNotFound)||![bValidIndexes containsIndex:bi]) {
            return(NSNotFound);
        }
        NSUInteger ai=aValidIndexes.firstIndex;
        for (NSNumber *c in atobMap) {
            if (c.intValue==bi) return(ai);
            ai=[aValidIndexes indexGreaterThanIndex:ai];
        }
        NSLog(@"Corrupt (IIM1)");
        return(NSNotFound);
    }
    -(NSUInteger)bIndexForAIndex:(NSUInteger)ai {
        if ((ai==NSNotFound)||![aValidIndexes containsIndex:ai]) {
            return(NSNotFound);
        }
        int aii=(int)[aValidIndexes countOfIndexesInRange:NSMakeRange(0,ai)];
        int bi=((NSNumber*)[atobMap objectAtIndex:aii]).intValue;
        return(bi);
    }

    -(bool)addAIndex:(NSUInteger)ai withBIndex:(NSUInteger)bi {
        if ((ai==NSNotFound)||[aValidIndexes containsIndex:ai]||[bValidIndexes containsIndex:bi]) {
            NSLog(@"Can't add (IIM1)");
            return(NO);
        }
        [aValidIndexes addIndex:ai];
        [bValidIndexes addIndex:bi];
        int aii=(int)[aValidIndexes countOfIndexesInRange:NSMakeRange(0,ai)];
        [atobMap insertObject:[NSNumber numberWithInt:(int)bi] atIndex:aii];
        return(YES);
    }
    -(bool)removeAIndex:(NSUInteger)ai {
        if ((ai==NSNotFound)||![aValidIndexes containsIndex:ai]) {
            NSLog(@"Can't remove (IIM1)");
            return(NO);
        }
        int aii=(int)[aValidIndexes countOfIndexesInRange:NSMakeRange(0,ai)];
        int bi=((NSNumber*)[atobMap objectAtIndex:aii]).intValue;
        
        [atobMap removeObjectAtIndex:aii];
        [aValidIndexes removeIndex:ai];
        [bValidIndexes removeIndex:bi];
        return(YES);
    }
    -(bool)shiftAIndexesFromIndex:(NSUInteger)fromi by:(int)d {
        if (d<0) {
            if (fromi<-d) {
                NSLog(@"Bad range (IIM1)");
                return(NO);
            }            
            NSUInteger i=[aValidIndexes indexGreaterThanOrEqualToIndex:fromi-d];
            if (i<fromi) {
                NSLog(@"Clobber (IIM2)");
                return(NO);
            }
        }
        [aValidIndexes shiftIndexesStartingAtIndex:fromi by:d];
        return(YES);
    }
    -(bool)shiftAIndexesInRange:(NSRange)r by:(int)d {
        if (d>0) {
            NSUInteger i=[aValidIndexes indexLessThanIndex:r.location+r.length+d];
            if (i>=r.location+r.length+d-MIN(d,r.length)) {
                NSLog(@"Clobber (IIM1)");
                return(NO);
            }
        }
        else if (d<0) {
            if (r.location<-d) {
                NSLog(@"Bad range (IIM1)");
                return(NO);
            }            
            NSUInteger i=[aValidIndexes indexGreaterThanOrEqualToIndex:r.location+d];
            if ((i<r.location)&&(i>=r.location+d)&&(i<r.location+d+r.length)) {
                NSLog(@"Clobber (IIM2)");
                return(NO);
            }
        }
        [aValidIndexes shiftIndexesStartingAtIndex:r.location+r.length by:-d];
        [aValidIndexes shiftIndexesStartingAtIndex:r.location by:d];
        return(YES);
    }
    -(bool)swapBIndexesForAIndex:(NSUInteger)ai1 andAIndex:(NSUInteger)ai2 {
        if ((ai1==NSNotFound)||![aValidIndexes containsIndex:ai1]) {
            NSLog(@"Can't swap (IIM1)");
            return(NO);
        }
        if ((ai2==NSNotFound)||![aValidIndexes containsIndex:ai2]) {
            NSLog(@"Can't swap (IIM2)");
            return(NO);
        }
        if (ai1!=ai2) {
            NSUInteger aii1=(int)[aValidIndexes countOfIndexesInRange:NSMakeRange(0,ai1)];
            NSUInteger aii2=(int)[aValidIndexes countOfIndexesInRange:NSMakeRange(0,ai2)];
            [atobMap exchangeObjectAtIndex:aii1 withObjectAtIndex:aii2];
        }
        return(YES);
    }
    -(void)setIdentityWithCount:(NSUInteger)N {
        self.aValidIndexes=[NSMutableIndexSet indexSetWithIndexesInRange:NSMakeRange(0,N)];
        self.bValidIndexes=[NSMutableIndexSet indexSetWithIndexesInRange:NSMakeRange(0,N)];
        self.atobMap=[NSMutableArray arrayWithCapacity:N];
        for (NSUInteger i=0;i<N;i++) [atobMap addObject:[NSNumber numberWithInt:(int)i]];
    }





