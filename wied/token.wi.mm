//Minim autogenerated this file. HaND

//Tasks:
//    Embedded 2 notes (look for "MARK:WI:" in the code)




#pragma mark -
#pragma mark Interfaces:
#ifdef INCLUDE_IFACE

#ifdef INCLUDE_IFACE_D0









@interface JsonParser : NSObject<Object, ClassObject> {
    LL __owner_context;
    @private ULL __private_access_thread_mask_in_JsonParser; @protected
    bool debugAutorelease;
    bool isZombie;
    LL objectIDInClass;
    LL objectIDInTotal;
}

@property (nonatomic,readwrite) LL __owner_context;
@property (nonatomic,readonly) constchar* cdescription;
@property (nonatomic,readonly) constchar* cobjectName;
@property (nonatomic,readwrite) bool debugAutorelease;
@property (nonatomic,readonly) NSString* description;
@property (nonatomic,readonly) bool isZombie;
@property (nonatomic,readonly) LL objectIDInClass;
@property (nonatomic,readonly) LL objectIDInTotal;
@property (nonatomic,readonly) NSMutableString* objectName;
-(void)_startObjectOfClassJsonParser;
+(NSObject*)_unpack:(NSArray*)tokens from:(Unsigned)from to:(Unsigned)to used:(Unsigned*)pused;
-(constchar*)cdescription;
-(constchar*)cobjectName;
-(void)dealloc;
-(NSString*)description;
-(void)die;
-(NSMutableString*)objectName;
+(NSObject*)unpackString:(NSString*)s;

@end









#endif // INCLUDE_IFACE_D0

#else // INCLUDE_IFACE





















#pragma mark -
#pragma mark Implementations:










// !!!: Implementations: j


















        #ifdef _PrivateAccessMask_
        #undef _PrivateAccessMask_
        #endif
        #define _PrivateAccessMask_ __private_access_thread_mask_in_Globals

#define _ClassName_ JsonParser
#define _WIClass_ JsonParser__
#define _className_ jsonParser
#define _Class_ JsonParser__
@implementation JsonParser

@synthesize __owner_context=__owner_context;
@synthesize debugAutorelease=debugAutorelease;
@synthesize isZombie=isZombie;
@synthesize objectIDInClass=objectIDInClass;
@synthesize objectIDInTotal=objectIDInTotal;
-(void)_startObjectOfClassJsonParser {MSGSTART("JsonParser:-(void)_startObjectOfClassJsonParser")
  
  /*i-996*/debugAutorelease=YES;
  /*i-995*/objInitFn(self,objectIDInTotal,objectIDInClass);
      
  /*i0*/}
+(NSObject*)_unpack:(NSArray*)tokens from:(Unsigned)from to:(Unsigned)to used:(Unsigned*)pused {MSGSTART("JsonParser:+(NSObject*)_unpack:(NSArray*)tokens from:(Unsigned)from to:(Unsigned)to used:(Unsigned*)pused")

          if (to<from) {*pused=0;return([NSNull null]);}
          WReaderToken *t0=[tokens objectAtIndex:from];
          if (t0.type=='n') {*pused=1;return(@(t0.str.doubleValue));}
          if (t0.type=='s') {
                NSString *s=[[t0.str substringWithRange:NSMakeRange(1,t0.str.length-2)] stringByDecodingCEscapes];
                *pused=1;
                return(s);
            }
          if ([t0.str isEqualToString:@"true"]) {*pused=1;return(@(YES));}
          if ([t0.str isEqualToString:@"false"]) {*pused=1;return(@(NO));}
          if ([t0.str isEqualToString:@"null"]) {*pused=1;return([NSNull null]);}
          if ([t0.str isEqualToString:@"undefined"]) {*pused=1;return([NSNull null]);}

          if (to>from) {
                WReaderToken *t1=[tokens objectAtIndex:from+1];
                if ([t0.str isEqualToString:@"-"]&&(t1.type=='n')) {
                      *pused=2;
                      return(@(-t1.str.doubleValue));
                  }
                if ([t0.str isEqualToString:@"{"]) {
                      NSMutableDictionary *ret=[[NSMutableDictionary alloc] init];
                      Unsigned fromWas=from;
                      from++;
                      WReaderToken *t=[tokens objectAtIndex:from];
                      if ([t.str isEqualToString:@"}"]) {
                            *pused=from+1-fromWas;
                            return(ret);
                        }
                      Unsigned used;
                      while (from<=to) {
                            NSObject *k=[JsonParser _unpack:tokens from:from to:to used:&used];
                            if (!(k&&[k conformsToProtocol:@protocol(NSCopying)])) {
                                  return(nil);
                              }
                            from+=used;
                            if (from>to) {
                                  return(nil);
                              }
                            t=[tokens objectAtIndex:from];
                            if (![t.str isEqualToString:@":"]) {
                                  return(nil);
                              }
                            from++;
                            NSObject *v=[JsonParser _unpack:tokens from:from to:to used:&used];
                            if (!v) {
                                  return(nil);
                              }
                            from+=used;
                            if (from>to) {
                                  return(nil);
                              }
                            [ret setObject:v forKey:(kid)k];
                            t=[tokens objectAtIndex:from];
                            if ([t.str isEqualToString:@"}"]) {
                                  *pused=from+1-fromWas;
                                  return(ret);
                              }
                            if (![t.str isEqualToString:@","]) {
                                  return(nil);
                              }
                            from++;
                        }
                      return(nil);
                  }
                if ([t0.str isEqualToString:@"["]) {
                      NSMutableArray *ret=[[NSMutableArray alloc] init];
                      Unsigned fromWas=from;
                      from++;
                      WReaderToken *t=[tokens objectAtIndex:from];
                      if ([t.str isEqualToString:@"]"]) {
                            *pused=from+1-fromWas;
                            return(ret);
                        }
                      Unsigned used;
                      while (from<=to) {
                            NSObject *v=[JsonParser _unpack:tokens from:from to:to used:&used];
                            if (!v) {
                                  return(nil);
                              }
                            from+=used;
                            if (from>to) {
                                  return(nil);
                              }
                            [ret addObject:v];
                            t=[tokens objectAtIndex:from];
                            if ([t.str isEqualToString:@"]"]) {
                                  *pused=from+1-fromWas;
                                  return(ret);
                              }
                            if (![t.str isEqualToString:@","]) {
                                  return(nil);
                              }
                            from++;
                        }
                      return(nil);
                  }
            }
          return(nil);
        
    }
-(constchar*)cdescription {MSGSTART("JsonParser:-(constchar*)cdescription")
  return([self.description cStringUsingEncoding:NSASCIIStringEncoding]);}
-(constchar*)cobjectName {MSGSTART("JsonParser:-(constchar*)cobjectName")
  return([self.objectName cStringUsingEncoding:NSASCIIStringEncoding]);}
-(void)dealloc {MSGSTART("JsonParser:-(void)dealloc")
  
  /*i-151*/[self die];
/*i998*/deallocFn(self,objectIDInTotal,objectIDInClass);
        isZombie=YES;
#if defined(LONGLIVEZOMBIES) || defined(LONGLIVEZOMBIES___WI_CLASS__)
        if (YES) return;
#endif
    
/*i999*/}
-(NSString*)description {MSGSTART("JsonParser:-(NSString*)description")
  
  /*i-999*/NSMutableString *ret=self.objectName;
          
  /*i999*/return(ret);
    }
-(void)die {MSGSTART("JsonParser:-(void)die")
  
  /*i900*/}
-(NSMutableString*)objectName {MSGSTART("JsonParser:-(NSMutableString*)objectName")
  
  /*i-999*/NSMutableString *ret=nil;
          
  /*i-100*/ret=[NSMutableString stringWithFormat:@"[%qu:%p]%s#%qu",objectIDInTotal,self,__Derived_CClass__,objectIDInClass];
          
  /*i999*/return(ret);
    }
+(NSObject*)unpackString:(NSString*)s {MSGSTART("JsonParser:+(NSObject*)unpackString:(NSString*)s")

          WReaderTokenizer *tk=[[WReaderTokenizer alloc] init];
          tk.str=s;
          NSMutableArray *a=[[NSMutableArray alloc] init];
          for (WReaderToken *t in tk.tokens) {
                if ((t.type!='s')&&(t.type!='n')&&
                  !(
                        [t.str isEqualToString:@"true"]||
                        [t.str isEqualToString:@"false"]||
                        [t.str isEqualToString:@"undefined"]||
                        [t.str isEqualToString:@"null"]||
                        [t.str isEqualToString:@"{"]||
                        [t.str isEqualToString:@"}"]||
                        [t.str isEqualToString:@"["]||
                        [t.str isEqualToString:@"]"]||
                        [t.str isEqualToString:@"-"]||
                        [t.str isEqualToString:@":"]||
                        [t.str isEqualToString:@","]
                      )) continue;
                [a addObject:t];
            }
          Unsigned used=0;
          NSObject *ret=a.count?[JsonParser _unpack:a from:0 to:a.count-1 used:&used]:nil;
          if (used!=a.count) ret=nil;
          return(ret);
    }

@end
#undef _ClassName_
#undef _WIClass_
#undef _className_
#undef _Class_


















#endif // INCLUDE_IFACE
