// WInterface autogenerated this file. HaND

// Tasks:
// Embedded 2 notes (look for "MARK:WI:" in the code)




#pragma mark -
#pragma mark Interfaces:
#ifdef INCLUDE_IFACE

    #ifdef INCLUDE_IFACE_D0





        @interface TokenHelper : NSObject<Object, ClassObject> {
            LL __owner_context;
            @private ULL __private_access_thread_mask_in_TokenHelper; @protected
            bool debugAutorelease;
            bool isZombie;
            LL objectIDInClass;
            LL objectIDInTotal;
        }

        @property (nonatomic,readwrite) LL __owner_context;
        @property (nonatomic,readonly) constchar *cdescription;
        @property (nonatomic,readonly) constchar *cobjectName;
        @property (nonatomic,readwrite) bool debugAutorelease;
        @property (nonatomic,readonly) NSString *description;
        @property (nonatomic,readonly) bool isZombie;
        @property (nonatomic,readonly) LL objectIDInClass;
        @property (nonatomic,readonly) LL objectIDInTotal;
        @property (nonatomic,readonly) NSMutableString *objectName;
        - (void)_startObjectOfClassTokenHelper;
        + (Token *)actualToken:(Token *)token;
        + (Token *)actualToken:(Token *)token havingRuleIn:(NSArray *)ruleNames;
        - (constchar *)cdescription;
        + (NSArray *)childrenForToken:(Token *)token;
        + (NSArray *)childrenForToken:(Token *)token havingRuleIn:(NSArray *)ruleNames;
        - (constchar *)cobjectName;
        - (void)dealloc;
        - (NSString *)description;
        - (void)die;
        + (bool)isJustSetting:(Token *)token;
        - (NSMutableString *)objectName;
        + (NSDictionary *)settingDictionaryForToken:(Token *)token addTo:(NSMutableDictionary *)ret;

        @end





        @interface Treeable : NSObject<Object, ClassObject> {
            LL __owner_context;
            @private ULL __private_access_thread_mask_in_Treeable; @protected
            bool debugAutorelease;
            bool isZombie;
            LL objectIDInClass;
            LL objectIDInTotal;
        }

        @property (nonatomic,readwrite) LL __owner_context;
        @property (nonatomic,readonly) constchar *cdescription;
        @property (nonatomic,readonly) constchar *cobjectName;
        @property (nonatomic,readwrite) bool debugAutorelease;
        @property (nonatomic,readonly) NSString *description;
        @property (nonatomic,readonly) bool isZombie;
        @property (nonatomic,readonly) LL objectIDInClass;
        @property (nonatomic,readonly) LL objectIDInTotal;
        @property (nonatomic,readonly) NSMutableString *objectName;
        - (void)_startObjectOfClassTreeable;
        + (NSMutableDictionary *)asD3Tree:(NSObject *)dictOrArray;
        + (NSMutableDictionary *)asTree:(NSMutableSet *)seen object:(NSObject<Treeable> *)me;
        - (constchar *)cdescription;
        - (constchar *)cobjectName;
        - (void)dealloc;
        - (NSString *)description;
        - (void)die;
        - (NSMutableString *)objectName;

        @end
    #endif // INCLUDE_IFACE_D0

#else  // INCLUDE_IFACE





    #pragma mark -
    #pragma mark Implementations:





// !!!: Implementations: t





    #ifdef _PrivateAccessMask_
        #undef _PrivateAccessMask_
    #endif
    #define _PrivateAccessMask_ __private_access_thread_mask_in_Globals

    #define _ClassName_         TokenHelper
    #define _WIClass_           TokenHelper__
    #define _className_         tokenHelper
    #define _Class_             TokenHelper__
    @implementation TokenHelper

    @synthesize __owner_context = __owner_context;
    @synthesize debugAutorelease = debugAutorelease;
    @synthesize isZombie = isZombie;
    @synthesize objectIDInClass = objectIDInClass;
    @synthesize objectIDInTotal = objectIDInTotal;
    - (void)_startObjectOfClassTokenHelper {
        MSGSTART("TokenHelper:-(void)_startObjectOfClassTokenHelper")

        /*i-996*/ debugAutorelease = YES;
        /*i-995*/ objInitFn(self,objectIDInTotal,objectIDInClass);

        /*i0*/}
    + (Token *)actualToken:(Token *)token {
        MSGSTART("TokenHelper:+(Token*)actualToken:(Token*)token")

        return [self actualToken:token havingRuleIn:nil];
    }
    + (Token *)actualToken:(Token *)token havingRuleIn:(NSArray *)ruleNames {
        MSGSTART("TokenHelper:+(Token*)actualToken:(Token*)token havingRuleIn:(NSArray*)ruleNames")

        while ([token.ruleName isEqualToString:@"par"]) token = token.children[0];
        return ruleNames && ![ruleNames containsObject:token.ruleName] ? nil : token;
    }
    - (constchar *)cdescription {
        MSGSTART("TokenHelper:-(constchar*)cdescription")
        return [self.description cStringUsingEncoding:NSASCIIStringEncoding];
    }
    + (NSArray *)childrenForToken:(Token *)token {
        MSGSTART("TokenHelper:+(NSArray*)childrenForToken:(Token*)token")

        return [self childrenForToken:token havingRuleIn:nil];
    }
    + (NSArray *)childrenForToken:(Token *)token havingRuleIn:(NSArray *)ruleNames {
        MSGSTART("TokenHelper:+(NSArray*)childrenForToken:(Token*)token havingRuleIn:(NSArray*)ruleNames")

        if (![self actualToken:token havingRuleIn:ruleNames]) {
            return nil;
        }
        else if ([token.ruleName isEqualToString:@"par"]) {
            Token *par = token.children[0];
            NSMutableArray *chs = [token.children subarrayWithRange:NSMakeRange(1,token.children.count - 1)].mutableCopy;
            while ([par.ruleName isEqualToString:@"par"]) {
                [chs addObjectsFromArray:[par.children subarrayWithRange:NSMakeRange(1,par.children.count - 1)]];
                par = par.children[0];
            }
            for (int i = 0; i < chs.count; i++) {
                while ( (i < chs.count) && [( (Token *)chs[i] ).ruleName isEqualToString : @"sib"] )
                    [chs replaceObjectsInRange:NSMakeRange(i,1) withObjectsFromArray:( (Token *)chs[i] ).children];
            }
            return chs;
        }
        else {
            return token.children;
        }
    }
    - (constchar *)cobjectName {
        MSGSTART("TokenHelper:-(constchar*)cobjectName")
        return [self.objectName cStringUsingEncoding:NSASCIIStringEncoding];
    }
    - (void)dealloc {
        MSGSTART("TokenHelper:-(void)dealloc")

        /*i-151*/[self die];
/*i998*/ deallocFn(self,objectIDInTotal,objectIDInClass);
        isZombie = YES;
    #if defined (LONGLIVEZOMBIES) || defined (LONGLIVEZOMBIES___WI_CLASS__)
            if (YES) return;
    #endif

/*i999*/}
    - (NSString *)description {
        MSGSTART("TokenHelper:-(NSString*)description")

        /*i-999*/ NSMutableString * ret = self.objectName;

        /*i999*/ return ret;
    }
    - (void)die {
        MSGSTART("TokenHelper:-(void)die")

        /*i900*/}
    + (bool)isJustSetting:(Token *)token {
        MSGSTART("TokenHelper:+(bool)isJustSetting:(Token*)token")

        if ([@[@"class",@"classwprotocol",@"protocol",@"var",@"fn"] containsObject : token.ruleName]) return NO;

        for (Token *ch in token.children) {
            if (![self isJustSetting:ch]) return NO;
        }
        return YES;
    }
    - (NSMutableString *)objectName {
        MSGSTART("TokenHelper:-(NSMutableString*)objectName")

        /*i-999*/ NSMutableString * ret = nil;

        /*i-100*/ ret = [NSMutableString stringWithFormat:@"[%qu:%p]%s#%qu",objectIDInTotal,self,__Derived_CClass__,objectIDInClass];

        /*i999*/ return ret;
    }
    + (NSDictionary *)settingDictionaryForToken:(Token *)token addTo:(NSMutableDictionary *)ret {
        MSGSTART("TokenHelper:+(NSDictionary*)settingDictionaryForToken:(Token*)token addTo:(NSMutableDictionary*)ret")

        if (!ret) ret = @{}
            .mutableCopy;
        Token *t = [TokenHelper actualToken:token];
        NSString *setting = t.contents;
        NSMutableDictionary *chrets = ret[setting];
        if (!chrets) ret[setting] = chrets = @{}
            .mutableCopy;

        if (t != token) {
            NSArray *chs = [TokenHelper childrenForToken:token];
            for (Token *ch in chs) {
                [self settingDictionaryForToken:ch addTo:chrets];
            }
        }
        return ret;
    }

    @end
    #undef _ClassName_
    #undef _WIClass_
    #undef _className_
    #undef _Class_





    #ifdef _PrivateAccessMask_
        #undef _PrivateAccessMask_
    #endif
    #define _PrivateAccessMask_ __private_access_thread_mask_in_Globals

    #define _ClassName_         Treeable
    #define _WIClass_           Treeable__
    #define _className_         treeable
    #define _Class_             Treeable__
    @implementation Treeable

    @synthesize __owner_context = __owner_context;
    @synthesize debugAutorelease = debugAutorelease;
    @synthesize isZombie = isZombie;
    @synthesize objectIDInClass = objectIDInClass;
    @synthesize objectIDInTotal = objectIDInTotal;
    - (void)_startObjectOfClassTreeable {
        MSGSTART("Treeable:-(void)_startObjectOfClassTreeable")

        /*i-996*/ debugAutorelease = YES;
        /*i-995*/ objInitFn(self,objectIDInTotal,objectIDInClass);

        /*i0*/}
    + (NSMutableDictionary *)asD3Tree:(NSObject *)dictOrArray {
        MSGSTART("Treeable:+(NSMutableDictionary*)asD3Tree:(NSObject*)dictOrArray")

        NSMutableArray * chs = @[].mutableCopy;
        NSMutableDictionary *ret = @{
            @"name":@"",
            @"linkname":@"",
            @"colour":@"black"
        }
        .mutableCopy;
        bool term = YES;


        if ([dictOrArray isKindOfClass:NSArray.class]) {
            term = NO;
            for (NSDictionary *d in(NSArray *) dictOrArray) {
                [chs addObject:[self asD3Tree:d]];
            }
            ret[@"colour"] = @"green";
        }
        else if ([dictOrArray isKindOfClass:NSDictionary.class]) {
            NSDictionary *dict = (NSDictionary *)dictOrArray;
            NSArray *names = [dict.allKeys sortedArrayUsingSelector:@selector(caseInsensitiveCompare:)];
            for (NSString *name in names) {
                if ( !([name isEqualToString:@"nodedata"]) ) {
                    if ([name isEqualToString:@"collapsed"]) {
                        ret[name] = dict[name];
                    }
                    else {
                        term = NO;
                        NSMutableDictionary *ch = [self asD3Tree:dict[name]];
                        if ( !([name hasPrefix:@" no linkname "] || [ch[@"name"] isEqualToString:name]) ) ch[@"linkname"] = name;
                        // if (!([name hasPrefix:@" no linkname "]||![ch[@"name"] length])) ch[@"name"]=name;
                        [chs addObject:ch];
                    }
                }
                else {
                    NSDictionary *data = dict[name];
                    if (data[@"name"]) ret[@"name"] = [data[@"name"] jsonString];
                    if (data[@"collapsed"]) ret[@"collapsed"] = data[@"collapsed"];
                    if (data[@"colour"]) ret[@"colour"] = data[@"colour"];
                    else if (data[@"type"])
                        switch ([@[@"File",@"Context",@"Class",@"Protocol",@"Type",@"VarContext",@"Var",@"Body",@"Snippet"] indexOfObject : data[@"type"]]) {
                            case NSNotFound : ret[@"colour"] = @"black"; break;

                            case 0: ret[@"colour"] = @"white"; break;

                            case 1: ret[@"colour"] = @"gray"; break;

                            case 2: ret[@"colour"] = @"red"; break;

                            case 3: ret[@"colour"] = @"purple"; break;

                            case 4: ret[@"colour"] = @"orange"; break;

                            case 5: ret[@"colour"] = @"green"; break;

                            case 6: ret[@"colour"] = @"blue"; break;

                            case 7: ret[@"colour"] = @"darkviolet"; break;

                            case 8: ret[@"colour"] = @"darkviolet"; break;
                        }
                    for (NSString *key in data) {
                        if ( !([key isEqualToString:@"name"] || [key isEqualToString:@"colour"] || [key isEqualToString:@"collapsed"] || [key isEqualToString:@"type"]) ) {
                            NSObject *o = data[key];
                            term = NO;
                            NSMutableDictionary *ch = [self asD3Tree:o];
                            if ( !([key hasPrefix:@" no linkname "] || [ch[@"name"] length]) ) ch[@"name"] = key;
                            else ch[@"linkname"] = key;
                            [chs addObject:ch];
                        }
                    }
                }
            }
        }
        else {
            ret[@"name"] = dictOrArray.jsonString;
            ret[@"colour"] = @"orange";
        }

        if (!term) ret[@"children"] = chs;
        if ( !([ret[@"linkname"] hasPrefix:@" no linkname "] || [ret[@"name"] length]) ) {
            ret[@"name"] = ret[@"linkname"];
            ret[@"linkname"] = @"";
        }
        ret[@"size"] = @(743 *[ret[@"name"] length] / 9);
        return ret;
    }
    + (NSMutableDictionary *)asTree:(NSMutableSet *)seen object:(NSObject<Treeable> *)me {
        MSGSTART("Treeable:+(NSMutableDictionary*)asTree:(NSMutableSet*)seen object:(NSObject<Treeable>*)me")

        NSMutableDictionary * ret = NSMutableDictionary.dictionary;

        if ([seen containsObject:me]) {
            NSDictionary *d = me.seenTreeNodeData;
            NSMutableDictionary *md = @{}
            .mutableCopy;
            ret[@"nodedata"] = md;
            for (id<NSCopying> k in d) {
                if (![d[k] isKindOfClass:NSNull.class]) md[k] = d[k];
            }
            [ret setObject:@YES forKey:@"collapsed"];
        }
        else {
            [seen addObject:me];
            NSDictionary *d = me.treeNodeData;
            NSMutableDictionary *md = @{}
            .mutableCopy;
            ret[@"nodedata"] = md;
            for (id<NSCopying> k in d) {
                if (![d[k] isKindOfClass:NSNull.class]) md[k] = d[k];
            }

            for (NSString __strong *name in me.treePropertyNames) {
                bool collapsed = [name hasPrefix:@"__"];
                if (collapsed) name = [name substringFromIndex:@"__".length];
                id res = [me performUnknownSelector:NSSelectorFromString(name)];
                if ([res isKindOfClass:NSNull.class]) continue;
                if ([res isKindOfClass:NSSet.class] || [res isKindOfClass:NSArray.class]) {
                    if ([(NSSet *)res count]) {
                        NSMutableArray *chs = NSMutableArray.array;
                        for (NSObject *ch in(NSSet *) res) {
                            if ([ch conformsToProtocol:@protocol(Treeable)])
                                [chs addObject:[(id < Treeable >) ch asTree : seen]];
                            else if (![ch isKindOfClass:NSNull.class])
                                [chs addObject:ch];
                        }
                        [ret setObject:chs forKey:name];
                    }
                }
                else if ([res isKindOfClass:NSDictionary.class]) {
                    if ([(NSDictionary *)res count]) {
                        NSMutableDictionary *chs = NSMutableDictionary.dictionary;
                        if (collapsed) chs[@"collapsed"] = @YES;
                        for (NSObject<NSCopying> *key in(NSDictionary *) res) {
                            NSObject *ch = ( (NSDictionary *)res )[key];
                            if ([ch isKindOfClass:NSNull.class]) continue;
                            if ([ch conformsToProtocol:@protocol(Treeable)])
                                [chs setObject:[(id < Treeable >) ch asTree : seen] forKey:[@" no linkname " stringByAppendingString :[(id)key jsonString]]];
                            else
                                [chs setObject:ch.jsonString forKey:key.jsonString];
                        }
                        [ret setObject:chs forKey:name];
                    }
                }
                else if ([res conformsToProtocol:@protocol(Treeable)]) {
                    NSMutableDictionary *chd = [(id < Treeable >) res asTree : seen];
                    if (collapsed) chd[@"collapsed"] = @YES;
                    [ret setObject:chd forKey:[@"" stringByAppendingString : name]];
                }
            }

            for (NSString __strong *name in me.treeSingleNodePropertyNames) {
                bool collapsed = [name hasPrefix:@"__"];
                if (collapsed) name = [name substringFromIndex:@"__".length];
                id res = [me performUnknownSelector:NSSelectorFromString(name)];
                if ([res isKindOfClass:NSNull.class]) continue;
                if ([res isKindOfClass:NSSet.class] || [res isKindOfClass:NSArray.class]) {
                    if ([(NSSet *)res count]) {
                        NSMutableArray *chs = NSMutableArray.array;
                        for (NSObject *ch in(NSSet *) res) {
                            if ([ch conformsToProtocol:@protocol(Treeable)])
                                [chs addObject:@{@"nodedata":( (id<Treeable> )ch ).seenTreeNodeData}
                                ];
                            else if (![ch isKindOfClass:NSNull.class])
                                [chs addObject:ch];
                        }
                        [ret setObject:chs forKey:name];
                    }
                }
                else if ([res isKindOfClass:NSDictionary.class]) {
                    if ([(NSDictionary *)res count]) {
                        NSMutableDictionary *chs = NSMutableDictionary.dictionary;
                        for (NSObject<NSCopying> *key in(NSDictionary *) res) {
                            NSObject *ch = ( (NSDictionary *)res )[key];
                            if ([ch isKindOfClass:NSNull.class]) continue;
                            if ([ch conformsToProtocol:@protocol(Treeable)])
                                [chs setObject:@{@"nodedata":( (id<Treeable> )ch ).seenTreeNodeData}
                                 forKey:[@" no linkname " stringByAppendingString : key.jsonString]];
                            else
                                [chs setObject:ch.jsonString forKey:key.jsonString];
                        }
                        [ret setObject:chs forKey:name];
                    }
                }
                else if ([res conformsToProtocol:@protocol(Treeable)]) {
                    [ret setObject:@{@"nodedata":( (id<Treeable> )res ).seenTreeNodeData}
                     forKey:[@"" stringByAppendingString : name]];
                }
            }
        }
        return ret;
    }
    - (constchar *)cdescription {
        MSGSTART("Treeable:-(constchar*)cdescription")
        return [self.description cStringUsingEncoding:NSASCIIStringEncoding];
    }
    - (constchar *)cobjectName {
        MSGSTART("Treeable:-(constchar*)cobjectName")
        return [self.objectName cStringUsingEncoding:NSASCIIStringEncoding];
    }
    - (void)dealloc {
        MSGSTART("Treeable:-(void)dealloc")

        /*i-151*/[self die];
/*i998*/ deallocFn(self,objectIDInTotal,objectIDInClass);
        isZombie = YES;
    #if defined (LONGLIVEZOMBIES) || defined (LONGLIVEZOMBIES___WI_CLASS__)
            if (YES) return;
    #endif

/*i999*/}
    - (NSString *)description {
        MSGSTART("Treeable:-(NSString*)description")

        /*i-999*/ NSMutableString * ret = self.objectName;

        /*i999*/ return ret;
    }
    - (void)die {
        MSGSTART("Treeable:-(void)die")

        /*i900*/}
    - (NSMutableString *)objectName {
        MSGSTART("Treeable:-(NSMutableString*)objectName")

        /*i-999*/ NSMutableString * ret = nil;

        /*i-100*/ ret = [NSMutableString stringWithFormat:@"[%qu:%p]%s#%qu",objectIDInTotal,self,__Derived_CClass__,objectIDInClass];

        /*i999*/ return ret;
    }

    @end
    #undef _ClassName_
    #undef _WIClass_
    #undef _className_
    #undef _Class_
#endif  // INCLUDE_IFACE
