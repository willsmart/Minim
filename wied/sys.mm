// WInterface autogenerated this file. HaND

// Tasks:
// Embedded 2 notes (look for "MARK:WI:" in the code)




#pragma mark -
#pragma mark Interfaces:
#ifdef INCLUDE_IFACE

    #ifdef INCLUDE_IFACE_D0





        @interface NSObject (winterface)


        @property (nonatomic,readonly) NSObject *asValidJsonObject;
        @property (nonatomic,readonly) NSString *jsonString;
        - (NSObject *)asValidJsonObject;
        - (bool)isWeakSelf;
        - (NSString *)jsonString;
        - (id)performUnknownSelector:(SEL)aSelector;
        - (void)performUnknownSelector:(SEL)aSelector onThread:(NSThread *)thread withObject:(id)arg waitUntilDone:(BOOL)wait;
        - (void)performUnknownSelector:(SEL)aSelector onThread:(NSThread *)thread withObject:(id)arg waitUntilDone:(BOOL)wait modes:(NSArray *)array;
        - (void)performUnknownSelector:(SEL)aSelector withObject:(id)anArgument afterDelay:(NSTimeInterval)delay;
        - (void)performUnknownSelector:(SEL)aSelector withObject:(id)anArgument afterDelay:(NSTimeInterval)delay inModes:(NSArray *)modes;
        - (id)performUnknownSelector:(SEL)aSelector withObject:(id)anObject;
        - (id)performUnknownSelector:(SEL)aSelector withObject:(id)anObject withObject:(id)anotherObject;
        - (void)performUnknownSelectorInBackground:(SEL)aSelector withObject:(id)arg;
        - (void)performUnknownSelectorOnMainThread:(SEL)aSelector withObject:(id)arg waitUntilDone:(BOOL)wait;
        - (void)performUnknownSelectorOnMainThread:(SEL)aSelector withObject:(id)arg waitUntilDone:(BOOL)wait modes:(NSArray *)array;
        - (void)performUnknownVoidSelector:(SEL)aSelector;
        - (void)performUnknownVoidSelector:(SEL)aSelector withObject:(id)anObject;
        - (void)performUnknownVoidSelector:(SEL)aSelector withObject:(id)anObject withObject:(id)anotherObject;
        - (id)selfWithWeakness:(bool)weak;
        - (id)strongSelf;
        - (WeakSelf *)weakSelf;

        @end





        @interface NSString (winterface)


        @property (nonatomic,readonly) NSObject *asValidJsonObject;
        @property (nonatomic,readonly) NSString *JSONString;
        @property (nonatomic,readonly) NSString *jsonString;
        @property (nonatomic,readonly) NSRegularExpression *stringAsRegularExpression;
        - (void)applyRegexes:(NSObject *)regexesArrayOrDictionary mutableString:(NSMutableString *__strong *)pmutableString;
        - (NSObject *)asValidJsonObject;
        - (BOOL)isMatchedByRegex:(NSRegularExpression *)regex;
        - (NSString *)JSONString;
        - (NSString *)jsonString;
        + (NSString *)JSONStringForCString:(const char *)from withLength:(Int)N useTmpDataObject:(NSMutableData *)d;
        + (const unichar *)JSONunicharsStringForCString:(const char *)from withLength:(Int)N useTmpDataObject:(NSMutableData *__strong *)pd retLength:(Int *)retLength;
        - (NSString *)replaceEnvironmentVariables_error:(NSError *__strong *)perror;
        + (StringRequestURLDelegate *)requestStringWithContentsOfURL:(NSURL *)aurl encoding:(NSStringEncoding)encoding timeoutInterval:(float)timeout completion:(StringRequestURLDelegateCompletionBlock)completionBlock;
        - (NSRegularExpression *)stringAsRegularExpression;
        - (NSString *)stringByApplyingRegexes:(NSObject *)regexesArrayOrDictionary;
        - (NSString *)stringByDecodingCEscapes;
        - (NSString *)stringByEncodingCEscapes;
        - (NSString *)stringByEncodingHTMLEntities;
        - (NSString *)stringByReplacingPairs:(NSObject *)firstNeedle,...;
        + (NSString *)stringWithContentsOfURL:(NSURL *)aurl encoding:(NSStringEncoding)encoding error:(NSError *__strong *)aerr timeoutInterval:(float)timeout;
        - (unichar *)unicharCString;
        - (NSString *)urlEncodeUsingEncoding:(NSStringEncoding)encoding;

        @end
    #endif // INCLUDE_IFACE_D0

#else  // INCLUDE_IFACE





    #pragma mark -
    #pragma mark Implementations:





// !!!: Implementations: n





    #ifdef _PrivateAccessMask_
        #undef _PrivateAccessMask_
    #endif
    #define _PrivateAccessMask_ __private_access_thread_mask_in_Globals

    #define _ClassName_         NSObject
    #define _WIClass_           NSObject__
    #define _className_         nSObject
    #define _Class_             NSObject__
    @implementation NSObject (winterface)

    - (NSObject *)asValidJsonObject {
        MSGSTART("NSObject:-(NSObject*)asValidJsonObject")
        return self.description;
    }
    - (bool)isWeakSelf {
        MSGSTART("NSObject:-(bool)isWeakSelf")
        return NO;
    }
    - (NSString *)jsonString {
        MSGSTART("NSObject:-(NSString*)jsonString")
        return self.description;
    }
    - (id)performUnknownSelector:(SEL)aSelector {
        MSGSTART("NSObject:-(id)performUnknownSelector:(SEL)aSelector")

    #pragma clang diagnostic push
    #pragma clang diagnostic ignored "-Warc-performSelector-leaks"
        return [self performSelector:aSelector];

    #pragma clang diagnostic pop
    }
    - (void)performUnknownSelector:(SEL)aSelector onThread:(NSThread *)thread withObject:(id)arg waitUntilDone:(BOOL)wait {
        MSGSTART("NSObject:-(void)performUnknownSelector:(SEL)aSelector onThread:(NSThread *)thread withObject:(id)arg waitUntilDone:(BOOL)wait")

    #pragma clang diagnostic push
    #pragma clang diagnostic ignored "-Warc-performSelector-leaks"
        [self performSelector : aSelector onThread : thread withObject : arg waitUntilDone : wait];
    #pragma clang diagnostic pop
    }
    - (void)performUnknownSelector:(SEL)aSelector onThread:(NSThread *)thread withObject:(id)arg waitUntilDone:(BOOL)wait modes:(NSArray *)array {
        MSGSTART("NSObject:-(void)performUnknownSelector:(SEL)aSelector onThread:(NSThread *)thread withObject:(id)arg waitUntilDone:(BOOL)wait modes:(NSArray *)array")

    #pragma clang diagnostic push
    #pragma clang diagnostic ignored "-Warc-performSelector-leaks"
        [self performSelector : aSelector onThread : thread withObject : arg waitUntilDone : wait modes : array];
    #pragma clang diagnostic pop
    }
    - (void)performUnknownSelector:(SEL)aSelector withObject:(id)anArgument afterDelay:(NSTimeInterval)delay {
        MSGSTART("NSObject:-(void)performUnknownSelector:(SEL)aSelector withObject:(id)anArgument afterDelay:(NSTimeInterval)delay")

    #pragma clang diagnostic push
    #pragma clang diagnostic ignored "-Warc-performSelector-leaks"
        [self performSelector : aSelector withObject : anArgument afterDelay : delay];
    #pragma clang diagnostic pop
    }
    - (void)performUnknownSelector:(SEL)aSelector withObject:(id)anArgument afterDelay:(NSTimeInterval)delay inModes:(NSArray *)modes {
        MSGSTART("NSObject:-(void)performUnknownSelector:(SEL)aSelector withObject:(id)anArgument afterDelay:(NSTimeInterval)delay inModes:(NSArray *)modes")

    #pragma clang diagnostic push
    #pragma clang diagnostic ignored "-Warc-performSelector-leaks"
        [self performSelector : aSelector withObject : anArgument afterDelay : delay inModes : modes];
    #pragma clang diagnostic pop
    }
    - (id)performUnknownSelector:(SEL)aSelector withObject:(id)anObject {
        MSGSTART("NSObject:-(id)performUnknownSelector:(SEL)aSelector withObject:(id)anObject")

    #pragma clang diagnostic push
    #pragma clang diagnostic ignored "-Warc-performSelector-leaks"
        return [self performSelector:aSelector withObject:anObject];

    #pragma clang diagnostic pop
    }
    - (id)performUnknownSelector:(SEL)aSelector withObject:(id)anObject withObject:(id)anotherObject {
        MSGSTART("NSObject:-(id)performUnknownSelector:(SEL)aSelector withObject:(id)anObject withObject:(id)anotherObject")

    #pragma clang diagnostic push
    #pragma clang diagnostic ignored "-Warc-performSelector-leaks"
        return [self performSelector:aSelector withObject:anObject withObject:anotherObject];

    #pragma clang diagnostic pop
    }
    - (void)performUnknownSelectorInBackground:(SEL)aSelector withObject:(id)arg {
        MSGSTART("NSObject:-(void)performUnknownSelectorInBackground:(SEL)aSelector withObject:(id)arg")

    #pragma clang diagnostic push
    #pragma clang diagnostic ignored "-Warc-performSelector-leaks"
        [self performSelectorInBackground : aSelector withObject : arg];
    #pragma clang diagnostic pop
    }
    - (void)performUnknownSelectorOnMainThread:(SEL)aSelector withObject:(id)arg waitUntilDone:(BOOL)wait {
        MSGSTART("NSObject:-(void)performUnknownSelectorOnMainThread:(SEL)aSelector withObject:(id)arg waitUntilDone:(BOOL)wait")

    #pragma clang diagnostic push
    #pragma clang diagnostic ignored "-Warc-performSelector-leaks"
        [self performSelectorOnMainThread : aSelector withObject : arg waitUntilDone : wait];
    #pragma clang diagnostic pop
    }
    - (void)performUnknownSelectorOnMainThread:(SEL)aSelector withObject:(id)arg waitUntilDone:(BOOL)wait modes:(NSArray *)array {
        MSGSTART("NSObject:-(void)performUnknownSelectorOnMainThread:(SEL)aSelector withObject:(id)arg waitUntilDone:(BOOL)wait modes:(NSArray *)array")

    #pragma clang diagnostic push
    #pragma clang diagnostic ignored "-Warc-performSelector-leaks"
        [self performSelectorOnMainThread : aSelector withObject : arg waitUntilDone : wait modes : array];
    #pragma clang diagnostic pop
    }
    - (void)performUnknownVoidSelector:(SEL)aSelector {
        MSGSTART("NSObject:-(void)performUnknownVoidSelector:(SEL)aSelector")

    #pragma clang diagnostic push
    #pragma clang diagnostic ignored "-Warc-performSelector-leaks"
        [self performSelector : aSelector];
    #pragma clang diagnostic pop
    }
    - (void)performUnknownVoidSelector:(SEL)aSelector withObject:(id)anObject {
        MSGSTART("NSObject:-(void)performUnknownVoidSelector:(SEL)aSelector withObject:(id)anObject")

    #pragma clang diagnostic push
    #pragma clang diagnostic ignored "-Warc-performSelector-leaks"
        [self performSelector : aSelector withObject : anObject];
    #pragma clang diagnostic pop
    }
    - (void)performUnknownVoidSelector:(SEL)aSelector withObject:(id)anObject withObject:(id)anotherObject {
        MSGSTART("NSObject:-(void)performUnknownVoidSelector:(SEL)aSelector withObject:(id)anObject withObject:(id)anotherObject")

    #pragma clang diagnostic push
    #pragma clang diagnostic ignored "-Warc-performSelector-leaks"
        [self performSelector : aSelector withObject : anObject withObject : anotherObject];
    #pragma clang diagnostic pop
    }
    - (id)selfWithWeakness:(bool)weak {
        MSGSTART("NSObject:-(id)selfWithWeakness:(bool)weak")
        return weak ? self.weakSelf : self;
    }
    - (id)strongSelf {
        MSGSTART("NSObject:-(id)strongSelf")
        return self;
    }
    - (WeakSelf *)weakSelf {
        MSGSTART("NSObject:-(WeakSelf*)weakSelf")
        void *key = @selector(weakSelf);
        WeakSelf *weakSelf = objc_getAssociatedObject(self,key);
        if (!weakSelf)
            objc_setAssociatedObject(self, key, weakSelf = [WeakSelf weakSelfFromObject:self], OBJC_ASSOCIATION_RETAIN_NONATOMIC);
        return weakSelf;
    }

    @end
    #undef _ClassName_
    #undef _WIClass_
    #undef _className_
    #undef _Class_





    #ifdef _PrivateAccessMask_
        #undef _PrivateAccessMask_
    #endif
    #define _PrivateAccessMask_ __private_access_thread_mask_in_Globals

    #define _ClassName_         NSString
    #define _WIClass_           NSString__
    #define _className_         nSString
    #define _Class_             NSString__
    @implementation NSString (winterface)

    - (void)applyRegexes:(NSObject *)regexesArrayOrDictionary mutableString:(NSMutableString *__strong *)pmutableString {
        MSGSTART("NSString:-(void)applyRegexes:(NSObject*)regexesArrayOrDictionary mutableString:(NSMutableString*__strong*)pmutableString")

        NSMutableString * __strong &mutableString = *pmutableString;
        if ([regexesArrayOrDictionary isKindOfClass:NSArray.class])
            for (NSObject *o in(NSArray *) regexesArrayOrDictionary) {
                if (mutableString) [mutableString applyRegexes:o];
                else [self applyRegexes:o mutableString:pmutableString];
            }
        else if ([regexesArrayOrDictionary isKindOfClass:NSDictionary.class])
            for (NSString *regexStr in(NSDictionary *) regexesArrayOrDictionary) {
                NSString *replaceStr = ( (NSDictionary *)regexesArrayOrDictionary )[regexStr];
                if ( !([regexStr isKindOfClass:NSString.class] && [replaceStr isKindOfClass:NSString.class]) )
                    continue;
                NSRegularExpression *regex = [RegexHelper regexForString:regexStr];
                if (!regex) continue;
                if (mutableString) {
                    [mutableString match:regex replace:1000 withString:replaceStr];
                }
                else if ([self isMatchedByRegex:regex]) {
                    mutableString = self.mutableCopy;
                    [mutableString match:regex replace:1000 withString:replaceStr];
                }
            }
    }
    - (NSObject *)asValidJsonObject {
        MSGSTART("NSString:-(NSObject*)asValidJsonObject")
        return self;
    }
    - (BOOL)isMatchedByRegex:(NSRegularExpression *)regex {
        MSGSTART("NSString:-(BOOL)isMatchedByRegex:(NSRegularExpression*)regex")

        return [regex rangeOfFirstMatchInString:self options:0 range:NSMakeRange(0,self.length)].location != NSNotFound;
    }
    - (NSString *)JSONString {
        MSGSTART("NSString:-(NSString*)JSONString")
        return JSONStringForString(self);
    }
    - (NSString *)jsonString {
        MSGSTART("NSString:-(NSString*)jsonString")
        return self;
    }
    + (NSString *)JSONStringForCString:(const char *)from withLength:(Int)N useTmpDataObject:(NSMutableData *)d {
        MSGSTART("NSString:+(NSString*)JSONStringForCString:(const char *)from withLength:(Int)N useTmpDataObject:(NSMutableData*)d")

        return JSONStringForCString(from,N,d);
    }
    + (const unichar *)JSONunicharsStringForCString:(const char *)from withLength:(Int)N useTmpDataObject:(NSMutableData *__strong *)pd retLength:(Int *)retLength {
        MSGSTART("NSString:+(const unichar*)JSONunicharsStringForCString:(const char *)from withLength:(Int)N useTmpDataObject:(NSMutableData*__strong*)pd retLength:(Int*)retLength")

        return JSONunicharsStringForCString(from,N,pd,retLength);
    }
    - (NSString *)replaceEnvironmentVariables_error:(NSError *__strong *)perror {
        MSGSTART("NSString:-(NSString*)replaceEnvironmentVariables_error:(NSError*__strong*)perror")
        if (perror) *perror = nil;
        NSError *err = nil;
        NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:@"(?<=^|\\})([^\\{]*+)(?=$|\\{)|(?<=\\{)([^\\}]*+)(?=$|\\})" options:0 error:&err];
        NSArray *matches = [regex matchesInString:self options:0 range:NSMakeRange(0, self.length)];
        NSMutableString *ret = NSMutableString.string;

        for (NSTextCheckingResult *match in matches) {
            if ([match rangeAtIndex:1].location != NSNotFound) {
                [ret appendString:[self substringWithRange:[match rangeAtIndex:1]]];
            }
            else if ([match rangeAtIndex:2].location != NSNotFound) {
                NSString *var = [self substringWithRange:[match rangeAtIndex:2]];
                NSString *val = [[NSProcessInfo processInfo]environment][var];
                if (val) {
                    [ret appendString:val];
                }
                else {
                    if (perror) *perror = [NSError errorWithDomain:
                                           [NSString stringWithFormat:@"Couldn't find environment variable \"%@\" to expand string \"%@\"",var,self]
                                           code:0 userInfo:nil
                            ];
                    return nil;
                }
            }
        }
        return ret;
    }
    + (StringRequestURLDelegate *)requestStringWithContentsOfURL:(NSURL *)aurl encoding:(NSStringEncoding)encoding timeoutInterval:(float)timeout completion:(StringRequestURLDelegateCompletionBlock)completionBlock {
        MSGSTART("NSString:+(StringRequestURLDelegate*)requestStringWithContentsOfURL:(NSURL*)aurl encoding:(NSStringEncoding)encoding timeoutInterval:(float)timeout completion:(StringRequestURLDelegateCompletionBlock)completionBlock")

        if (!g_singletons.online) {
            completionBlock(nil,[NSError errorWithDomain:@"offline" code:1 userInfo:nil]);
            return nil;
        }
        NSURLRequest *req = [[NSURLRequest alloc]
                             initWithURL:aurl
                             cachePolicy:NSURLRequestUseProtocolCachePolicy
                             timeoutInterval:timeout];
        StringRequestURLDelegate *del = [[StringRequestURLDelegate alloc] initWithEncoding:encoding completionBlock:completionBlock];
        del.connection = [NSURLConnection connectionWithRequest:req delegate:del];
        return del;
    }
    - (NSRegularExpression *)stringAsRegularExpression {
        MSGSTART("NSString:-(NSRegularExpression*)stringAsRegularExpression")

        // [RKRegex regexWithRegexString:self options:RKCompileNoOptions];
        NSError * err = nil;
        return [NSRegularExpression regularExpressionWithPattern:self options:NSRegularExpressionDotMatchesLineSeparators error:&err];
    }
    - (NSString *)stringByApplyingRegexes:(NSObject *)regexesArrayOrDictionary {
        MSGSTART("NSString:-(NSString*)stringByApplyingRegexes:(NSObject*)regexesArrayOrDictionary")

        NSMutableString * ms = nil;
        [self applyRegexes:regexesArrayOrDictionary mutableString:&ms];
        return ms ? ms : self;
    }
    - (NSString *)stringByDecodingCEscapes {
        MSGSTART("NSString:-(NSString*)stringByDecodingCEscapes")

        return [self stringByReplacingPairs:@"\\\\",@"\\\\ ",@"\\t",@"\t",@"\\r",@"\r",@"\\n",@"\n",@"\\\"",@"\"",@"\\'",@"'",@"\\\\ ",@"\\",nil];
    }
    - (NSString *)stringByEncodingCEscapes {
        MSGSTART("NSString:-(NSString*)stringByEncodingCEscapes")

        return [self stringByReplacingPairs:@"\\",@"\\\\",@"\"",@"\\\"",@"\n",@"\\n",@"\r",@"\\r",@"\t",@"\\t",nil];
    }
    - (NSString *)stringByEncodingHTMLEntities {
        MSGSTART("NSString:-(NSString*)stringByEncodingHTMLEntities")

        return [self stringByReplacingPairs:@"&",@"&amp;",@"<",@"&lt;",@">",@"&gt;",@"\"",@"&quot;",@"\n",@"<br/>\n",nil];
    }
    - (NSString *)stringByReplacingPairs:(NSObject *)firstNeedle,... {
        MSGSTART("NSString:-(NSString*)stringByReplacingPairs:(NSObject*)firstNeedle,...")

        NSMutableString * s = self.mutableCopy;
        va_list args; va_start(args,firstNeedle);
        for ( NSObject *k = firstNeedle; k != nil; k = va_arg(args,NSObject *) ) {
            NSObject *o = va_arg(args,NSObject *);
            if (!o) break;
            if ([k isKindOfClass:[NSString class]] && [o isKindOfClass:[NSString class]])
                [s replaceOccurrencesOfString:(NSString *)k withString:(NSString *)o options:0 range:NSMakeRange(0, s.length)];
        }
        return s.copy;
    }
    + (NSString *)stringWithContentsOfURL:(NSURL *)aurl encoding:(NSStringEncoding)encoding error:(NSError *__strong *)aerr timeoutInterval:(float)timeout {
        MSGSTART("NSString:+(NSString*)stringWithContentsOfURL:(NSURL*)aurl encoding:(NSStringEncoding)encoding error:(NSError*__strong*)aerr timeoutInterval:(float)timeout")

        if (!g_singletons.online) return nil;

        NSURLRequest *req = [[NSURLRequest alloc]
                             initWithURL:aurl
                             cachePolicy:NSURLRequestUseProtocolCachePolicy
                             timeoutInterval:timeout];
        NSURLResponse *response;
        NSError *error = nil;
        NSData *data = [NSURLConnection sendSynchronousRequest:req returningResponse:&response error:&error];
        aerr = &error;
        return [[NSString alloc] initWithData:data encoding:encoding];
    }
    - (unichar *)unicharCString {
        MSGSTART("NSString:-(unichar*)unicharCString")

        NSMutableData * data = [NSMutableData dataWithLength:(self.length + 1) * sizeof(unichar)];
        objc_setAssociatedObject(self, @selector(unicharCString), data, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
        unichar *ret = (unichar *)data.mutableBytes;
        for (int i = 0; i < self.length; i++) {
            ret[i] = [self characterAtIndex:i];
        }
        ret[self.length] = 0;
        return ret;
    }
    - (NSString *)urlEncodeUsingEncoding:(NSStringEncoding)encoding {
        MSGSTART("NSString:-(NSString*)urlEncodeUsingEncoding:(NSStringEncoding)encoding")

        return (NSString *)CFBridgingRelease( CFURLCreateStringByAddingPercentEscapes( NULL,(CFStringRef)self,NULL,(CFStringRef)@"!*'\"();:@&=+$,/?%[]% ",CFStringConvertNSStringEncodingToEncoding(encoding) ) );
    }

    @end
    #undef _ClassName_
    #undef _WIClass_
    #undef _className_
    #undef _Class_
#endif  // INCLUDE_IFACE
