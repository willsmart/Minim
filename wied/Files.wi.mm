//Minim autogenerated this file. HaND

//Tasks:
//    Embedded 2 notes (look for "MARK:WI:" in the code)




#pragma mark -
#pragma mark Interfaces:
#ifdef INCLUDE_IFACE

#ifdef INCLUDE_IFACE_D0









@interface File : NSObject<Object, ClassObject> {
    LL __owner_context;
    @private ULL __private_access_thread_mask_in_File; @protected
    EndpointS* v_childrens;
    bool debugAutorelease;
    File* initialParent;
    bool isZombie;
    LL objectIDInClass;
    LL objectIDInTotal;
    EndpointS* v_parents;
    NSString* path;
    WIFile* wiFile;
}

@property (nonatomic,readwrite) LL __owner_context;
@property (nonatomic,readonly) constchar* cdescription;
@property (strong,nonatomic,readwrite/*(public readonly)*/) EndpointS* childrens;
@property (nonatomic,readonly) constchar* cobjectName;
@property (nonatomic,readwrite) bool debugAutorelease;
@property (nonatomic,readonly) NSString* description;
@property (strong,nonatomic,readonly) File* initialParent;
@property (nonatomic,readonly) bool isZombie;
@property (nonatomic,readonly) LL objectIDInClass;
@property (nonatomic,readonly) LL objectIDInTotal;
@property (nonatomic,readonly) NSMutableString* objectName;
@property (strong,nonatomic,readwrite/*(public readonly)*/) EndpointS* parents;
@property (strong,nonatomic,readonly) NSString* path;
@property (strong,nonatomic,readwrite) WIFile* wiFile;
-(void)_startObjectOfClassFile;
-(void)addChildren:(File*)v;
-(void)addParent:(File*)v;
-(constchar*)cdescription;
-(NSString*)childPathForPath:(NSString*)childPath;
-(EndpointS*)childrens;
-(NSObject<LinkEndpoint>*)childrenToEndpoint:(id)achildren;
-(File*)childWithPath:(NSString*)childPath;
-(constchar*)cobjectName;
-(void)dealloc;
-(NSString*)description;
-(void)die;
-(void)includeChildren;
-(File*)initFileWithPath:(NSString*)apath inParent:(File*)aparent;
-(File*)initialParent;
-(NSNumber*)isAcceptableChildren:(id)achildren;
-(NSNumber*)isAcceptableParent:(id)aparent;
+(instancetype)newFileWithPath:(NSString*)apath inParent:(File*)aparent;
-(NSMutableString*)objectName;
-(EndpointS*)parents;
-(NSObject<LinkEndpoint>*)parentToEndpoint:(id)aparent;
-(NSString*)path;
-(void)removeAllChildrens;
-(void)removeAllParents;
-(void)removeChildren:(File*)v;
-(void)removeParent:(File*)v;
-(void)retract;
-(void)setChildrens:(EndpointS*)v;
-(void)setParents:(EndpointS*)v;
-(void)setWiFile:(WIFile*)v;
-(WIFile*)wiFile;

@end









@interface Files : NSObject<Object, ClassObject> {
    LL __owner_context;
    @private ULL __private_access_thread_mask_in_Files; @protected
    NSString* v_basePath;
    bool debugAutorelease;
    NSMutableDictionary* files;
    bool isZombie;
    WIFile* merge;
    LL objectIDInClass;
    LL objectIDInTotal;
}

@property (nonatomic,readwrite) LL __owner_context;
@property (strong,nonatomic,readwrite) NSString* basePath;
@property (nonatomic,readonly) constchar* cdescription;
@property (nonatomic,readonly) constchar* cobjectName;
@property (nonatomic,readwrite) bool debugAutorelease;
@property (nonatomic,readonly) NSString* description;
@property (strong,nonatomic,readonly) NSMutableDictionary* files;
@property (nonatomic,readonly) bool isZombie;
@property (strong,nonatomic,readonly) WIFile* merge;
@property (nonatomic,readonly) LL objectIDInClass;
@property (nonatomic,readonly) LL objectIDInTotal;
@property (nonatomic,readonly) NSMutableString* objectName;
-(void)_startObjectOfClassFiles;
-(NSString*)basePath;
-(constchar*)cdescription;
-(constchar*)cobjectName;
-(void)dealloc;
-(NSString*)description;
-(void)die;
-(NSMutableDictionary*)files;
-(File*)fileWithPath:(NSString*)path;
-(Files*)init;
-(WIFile*)merge;
-(NSMutableString*)objectName;
-(NSString*)pathForPath:(NSString*)path;
-(void)setBasePath:(NSString*)v;
-(void)writeMergeHTML;

@end









@interface WIParse : NSObject<Object, ClassObject> {
    LL __owner_context;
    @private ULL __private_access_thread_mask_in_WIParse; @protected
    bool debugAutorelease;
    bool isZombie;
    LL objectIDInClass;
    LL objectIDInTotal;
}

@property (nonatomic,readwrite) LL __owner_context;
@property (nonatomic,readonly) constchar* cdescription;
@property (nonatomic,readonly) constchar* cobjectName;
@property (nonatomic,readwrite) bool debugAutorelease;
@property (nonatomic,readonly) NSString* description;
@property (nonatomic,readonly) bool isZombie;
@property (nonatomic,readonly) LL objectIDInClass;
@property (nonatomic,readonly) LL objectIDInTotal;
@property (nonatomic,readonly) NSMutableString* objectName;
-(void)_startObjectOfClassWIParse;
-(constchar*)cdescription;
-(constchar*)cobjectName;
-(void)dealloc;
-(NSString*)description;
-(void)die;
-(WIParse*)init;
-(NSMutableString*)objectName;
+(void)substituteStrings:(NSMutableArray*)tokens;
-(WIFile*)wiFileFromFile:(NSString*)path;

@end









#endif // INCLUDE_IFACE_D0

#else // INCLUDE_IFACE





















#pragma mark -
#pragma mark Implementations:










// !!!: Implementations: f


















        #ifdef _PrivateAccessMask_
        #undef _PrivateAccessMask_
        #endif
        #define _PrivateAccessMask_ __private_access_thread_mask_in_Globals

#define _ClassName_ File
#define _WIClass_ File__
#define _className_ file
#define _Class_ File__
@implementation File

@synthesize __owner_context=__owner_context;
@synthesize debugAutorelease=debugAutorelease;
@synthesize isZombie=isZombie;
@synthesize objectIDInClass=objectIDInClass;
@synthesize objectIDInTotal=objectIDInTotal;
-(void)_startObjectOfClassFile {MSGSTART("File:-(void)_startObjectOfClassFile")
  
  /*i-996*/debugAutorelease=YES;
  /*i-995*/objInitFn(self,objectIDInTotal,objectIDInClass);
      
  /*i-500*//*ivar*/v_childrens=([[EndpointS alloc] initWithOwner:self retains:NO acceptableSel:@selector(isAcceptableChildren:) otherEndObjectToEndpoint:@selector(childrenToEndpoint:)]);  ADDOWNER(v_childrens,self);
   /*ivar*/v_parents=([[EndpointS alloc] initWithOwner:self retains:NO acceptableSel:@selector(isAcceptableParent:) otherEndObjectToEndpoint:@selector(parentToEndpoint:)]);  ADDOWNER(v_parents,self);
  
  /*i0*/if (initialParent) [self addParent:initialParent];
          [self includeChildren];


    



}
-(void)addChildren:(File*)v {MSGSTART("File:-(void)addChildren:(File*)v")
  [v_childrens addObject:v];}
-(void)addParent:(File*)v {MSGSTART("File:-(void)addParent:(File*)v")
  [v_parents addObject:v];}
-(constchar*)cdescription {MSGSTART("File:-(constchar*)cdescription")
  return([self.description cStringUsingEncoding:NSASCIIStringEncoding]);}
-(NSString*)childPathForPath:(NSString*)childPath {MSGSTART("File:-(NSString*)childPathForPath:(NSString*)childPath")
  return childPath.isAbsolutePath?
              childPath:
              [path.stringByDeletingLastPathComponent stringByAppendingPathComponent:childPath];
}
-(EndpointS*)childrens {MSGSTART("File:-(EndpointS*)childrens")
  
  /*i-999*/EndpointS* ret=v_childrens;
  /*i999*/return(ret);}
-(NSObject<LinkEndpoint>*)childrenToEndpoint:(id)achildren {MSGSTART("File:-(NSObject<LinkEndpoint>*)childrenToEndpoint:(id)achildren")
  return([achildren performSelector:@selector(parents)]);}
-(File*)childWithPath:(NSString*)childPath {MSGSTART("File:-(File*)childWithPath:(NSString*)childPath")
  childPath=[self childPathForPath:childPath];
          File *ret=Singletons._.files.files[childPath];
          if (ret) [ret addParent:self];
          else ret=[File newFileWithPath:childPath inParent:self];
          return(ret);
}
-(constchar*)cobjectName {MSGSTART("File:-(constchar*)cobjectName")
  return([self.objectName cStringUsingEncoding:NSASCIIStringEncoding]);}
-(void)dealloc {MSGSTART("File:-(void)dealloc")
  
  /*i-151*/[self die];
/*i0*/REMOVEOWNER(v_childrens,self);v_childrens=nil;

    REMOVEOWNER(wiFile,self);wiFile=nil;

    REMOVEOWNER(v_parents,self);v_parents=nil;

    REMOVEOWNER(initialParent,self);initialParent=nil;

path=nil;
/*i998*/deallocFn(self,objectIDInTotal,objectIDInClass);
        isZombie=YES;
#if defined(LONGLIVEZOMBIES) || defined(LONGLIVEZOMBIES___WI_CLASS__)
        if (YES) return;
#endif
    
/*i999*/}
-(NSString*)description {MSGSTART("File:-(NSString*)description")
  
  /*i-999*/NSMutableString *ret=self.objectName;
          
  /*i999*/return(ret);
    }
-(void)die {MSGSTART("File:-(void)die")
  [v_childrens removeAllObjects];
  [v_parents removeAllObjects];
  
  /*i900*/}
-(void)includeChildren {MSGSTART("File:-(void)includeChildren")
  NSArray *includes=self.wiFile.includes;
          for (NSString *childPath in includes) {
                if ([childPath hasSuffix:@".wi"]) {
                      [self childWithPath:childPath];
                  }
            }
}
-(File*)initFileWithPath:(NSString*)apath inParent:(File*)aparent {MSGSTART("File:-(File*)initFileWithPath:(NSString*)apath inParent:(File*)aparent")
  
  /*i-10001*/if (!(self=[super init])) return(nil);
  
  /*i0*/initialParent=aparent;
          path=aparent?
              [aparent childPathForPath:apath]:
              [Singletons._.files pathForPath:apath];
          prnt("%s\n",path.UTF8String);
  
  /*i11*/[self _startObjectOfClassFile];

/*i10001*/return(self);}
-(File*)initialParent {MSGSTART("File:-(File*)initialParent")
  
  /*i-999*/File* ret=initialParent;
  /*i999*/return(ret);}
-(NSNumber*)isAcceptableChildren:(id)achildren {MSGSTART("File:-(NSNumber*)isAcceptableChildren:(id)achildren")
  return([achildren isKindOfClass:[File class]]?@YES:nil);}
-(NSNumber*)isAcceptableParent:(id)aparent {MSGSTART("File:-(NSNumber*)isAcceptableParent:(id)aparent")
  return([aparent isKindOfClass:[File class]]?@YES:nil);}
+(instancetype)newFileWithPath:(NSString*)apath inParent:(File*)aparent {MSGSTART("File:+(instancetype)newFileWithPath:(NSString*)apath inParent:(File*)aparent")
  return [[self alloc] initFileWithPath:apath inParent:aparent];
}
-(NSMutableString*)objectName {MSGSTART("File:-(NSMutableString*)objectName")
  
  /*i-999*/NSMutableString *ret=nil;
          
  /*i-100*/ret=[NSMutableString stringWithFormat:@"[%qu:%p]%s#%qu",objectIDInTotal,self,__Derived_CClass__,objectIDInClass];
          
  /*i999*/return(ret);
    }
-(EndpointS*)parents {MSGSTART("File:-(EndpointS*)parents")
  
  /*i-999*/EndpointS* ret=v_parents;
  /*i999*/return(ret);}
-(NSObject<LinkEndpoint>*)parentToEndpoint:(id)aparent {MSGSTART("File:-(NSObject<LinkEndpoint>*)parentToEndpoint:(id)aparent")
  return([aparent performSelector:@selector(childrens)]);}
-(NSString*)path {MSGSTART("File:-(NSString*)path")
  
  /*i-999*/NSString* ret=path;
  /*i999*/return(ret);}
-(void)removeAllChildrens {MSGSTART("File:-(void)removeAllChildrens")
  [v_childrens removeAllObjects];}
-(void)removeAllParents {MSGSTART("File:-(void)removeAllParents")
  [v_parents removeAllObjects];}
-(void)removeChildren:(File*)v {MSGSTART("File:-(void)removeChildren:(File*)v")
  [v_childrens removeObject:v];}
-(void)removeParent:(File*)v {MSGSTART("File:-(void)removeParent:(File*)v")
  [v_parents removeObject:v];}
-(void)retract {MSGSTART("File:-(void)retract")
  [self.childrens removeAllObjects];
  [self.parents removeAllObjects];}
-(void)setChildrens:(EndpointS*)v {MSGSTART("File:-(void)setChildrens:(EndpointS*)v")
  
  /*i-1999*/if (!authorized_thread(__private_access_thread_mask_in_File)) ERR("Attempt to set public-readonly property in unauthorized thread (please try something like privateaccess(childrens=\"blah\") to set the property)");
  
  /*i-905*/if(v_childrens==v)return;
  /*i-900*/{v_childrens=(id)v;}
/*i-850*/REMOVEOWNER(v_childrens,self);ADDOWNER(v,self);}
-(void)setParents:(EndpointS*)v {MSGSTART("File:-(void)setParents:(EndpointS*)v")
  
  /*i-1999*/if (!authorized_thread(__private_access_thread_mask_in_File)) ERR("Attempt to set public-readonly property in unauthorized thread (please try something like privateaccess(parents=\"blah\") to set the property)");
  
  /*i-905*/if(v_parents==v)return;
  /*i-900*/{v_parents=(id)v;}
/*i-850*/REMOVEOWNER(v_parents,self);ADDOWNER(v,self);}
-(void)setWiFile:(WIFile*)v {MSGSTART("File:-(void)setWiFile:(WIFile*)v")
  
  /*i-905*/if(wiFile==v)return;
  /*i-900*/{wiFile=(id)v;}
/*i-850*/REMOVEOWNER(wiFile,self);ADDOWNER(v,self);}
-(WIFile*)wiFile {MSGSTART("File:-(WIFile*)wiFile")

              if (path&&!wiFile) {
                    wiFile=[Singletons._.wiParse wiFileFromFile:path];
                    [Singletons._.files.merge mergeWith:wiFile];
                }
              return(wiFile);
        }

@end
#undef _ClassName_
#undef _WIClass_
#undef _className_
#undef _Class_









        #ifdef _PrivateAccessMask_
        #undef _PrivateAccessMask_
        #endif
        #define _PrivateAccessMask_ __private_access_thread_mask_in_Globals

#define _ClassName_ Files
#define _WIClass_ Files__
#define _className_ files
#define _Class_ Files__
@implementation Files

@synthesize __owner_context=__owner_context;
@synthesize debugAutorelease=debugAutorelease;
@synthesize isZombie=isZombie;
@synthesize objectIDInClass=objectIDInClass;
@synthesize objectIDInTotal=objectIDInTotal;
-(void)_startObjectOfClassFiles {MSGSTART("Files:-(void)_startObjectOfClassFiles")
  
  /*i-996*/debugAutorelease=YES;
  /*i-995*/objInitFn(self,objectIDInTotal,objectIDInClass);
      
  /*i-500*//*ivar*/merge=([WIFile new]);  ADDOWNER(merge,self);
   /*ivar*/v_basePath=([[NSFileManager defaultManager] currentDirectoryPath]);
  
  /*i0*/}
-(NSString*)basePath {MSGSTART("Files:-(NSString*)basePath")
  return(v_basePath);}
-(constchar*)cdescription {MSGSTART("Files:-(constchar*)cdescription")
  return([self.description cStringUsingEncoding:NSASCIIStringEncoding]);}
-(constchar*)cobjectName {MSGSTART("Files:-(constchar*)cobjectName")
  return([self.objectName cStringUsingEncoding:NSASCIIStringEncoding]);}
-(void)dealloc {MSGSTART("Files:-(void)dealloc")
  
  /*i-151*/[self die];
/*i0*/REMOVEOWNER(merge,self);merge=nil;

files=nil;

v_basePath=nil;
/*i998*/deallocFn(self,objectIDInTotal,objectIDInClass);
        isZombie=YES;
#if defined(LONGLIVEZOMBIES) || defined(LONGLIVEZOMBIES___WI_CLASS__)
        if (YES) return;
#endif
    
/*i999*/}
-(NSString*)description {MSGSTART("Files:-(NSString*)description")
  
  /*i-999*/NSMutableString *ret=self.objectName;
          
  /*i999*/return(ret);
    }
-(void)die {MSGSTART("Files:-(void)die")
  
  /*i900*/}
-(NSMutableDictionary*)files {MSGSTART("Files:-(NSMutableDictionary*)files")
  
  /*i-999*/NSMutableDictionary* ret=files;
  /*i999*/return(ret);}
-(File*)fileWithPath:(NSString*)path {MSGSTART("Files:-(File*)fileWithPath:(NSString*)path")
  path=[self pathForPath:path];
          if (!files) files=@{}.mutableCopy;
          return files[path]?
              files[path]:
              ((files[path]=[File newFileWithPath:path inParent:nil]));
}
-(Files*)init {MSGSTART("Files:-(Files*)init")
  
  /*i-10001*/if (!(self=[super init])) return(nil);
  
  /*i11*/[self _startObjectOfClassFiles];

/*i10001*/return(self);}
-(WIFile*)merge {MSGSTART("Files:-(WIFile*)merge")
  
  /*i-999*/WIFile* ret=merge;
  /*i999*/return(ret);}
-(NSMutableString*)objectName {MSGSTART("Files:-(NSMutableString*)objectName")
  
  /*i-999*/NSMutableString *ret=nil;
          
  /*i-100*/ret=[NSMutableString stringWithFormat:@"[%qu:%p]%s#%qu",objectIDInTotal,self,__Derived_CClass__,objectIDInClass];
          
  /*i999*/return(ret);
    }
-(NSString*)pathForPath:(NSString*)path {MSGSTART("Files:-(NSString*)pathForPath:(NSString*)path")
  if (!path.isAbsolutePath) path=[self.basePath stringByAppendingPathComponent:path];
          return(path);//[[NSURL URLWithString:path relativeToURL:NSBundle.mainBundle.bundleURL] absoluteString]);
}
-(void)setBasePath:(NSString*)v {MSGSTART("Files:-(void)setBasePath:(NSString*)v")

              v=[v stringByTrimmingCharactersInSet:NSCharacterSet.whitespaceAndNewlineCharacterSet];
              if (!v.isAbsolutePath) {
                    NSFileManager *fm=NSFileManager.defaultManager;
                    v=(v?[fm.currentDirectoryPath stringByAppendingPathComponent:v]:fm.currentDirectoryPath);
                }
              v_basePath=v;
        }
-(void)writeMergeHTML {MSGSTART("Files:-(void)writeMergeHTML")

          NSError *err=nil;
          NSDictionary *d=@{
                @"prog":@"merge",
                @"graph":[Parse graphFromTokens:@[]],
                @"parsedgraph":merge.asD3Tree
            };
          NSString *htmlfn=[Singletons._.files pathForPath:@"merge.html"];
          NSString *json=[[NSString alloc] initWithData:[NSJSONSerialization dataWithJSONObject:d options:0 error:&err] encoding:NSUTF8StringEncoding];
          NSString *html=[NSString stringWithContentsOfFile:@"/Users/Will/mycode/Minim/Parse/index.html" encoding:NSUTF8StringEncoding error:&err];
          html=[html stringByReplacingOccurrencesOfString:@"\"JSONDATA\"" withString:json];
          [html writeToFile:htmlfn atomically:YES encoding:NSUTF8StringEncoding error:&err];
          [Singletons._.htmlParseOutput appendFormat:@"<strong><a href='file:%@'>%@</a></strong><br/>",htmlfn,@"Merge of all the files above"];

          [merge applyRegexes];
        
          d=@{
                @"prog":@"post regex",
                @"graph":[Parse graphFromTokens:@[]],
                @"parsedgraph":merge.asD3Tree
            };
          htmlfn=[Singletons._.files pathForPath:@"post-regex.html"];
          json=[[NSString alloc] initWithData:[NSJSONSerialization dataWithJSONObject:d options:0 error:&err] encoding:NSUTF8StringEncoding];
          html=[NSString stringWithContentsOfFile:@"/Users/Will/mycode/Minim/Parse/index.html" encoding:NSUTF8StringEncoding error:&err];
          html=[html stringByReplacingOccurrencesOfString:@"\"JSONDATA\"" withString:json];
          [html writeToFile:htmlfn atomically:YES encoding:NSUTF8StringEncoding error:&err];
          [Singletons._.htmlParseOutput appendFormat:@"<strong><a href='file:%@'>%@</a></strong><br/>",htmlfn,@"Merge after applying regexes"];
    }

@end
#undef _ClassName_
#undef _WIClass_
#undef _className_
#undef _Class_


















// !!!: Implementations: w


















        #ifdef _PrivateAccessMask_
        #undef _PrivateAccessMask_
        #endif
        #define _PrivateAccessMask_ __private_access_thread_mask_in_Globals

#define _ClassName_ WIParse
#define _WIClass_ WIParse__
#define _className_ wIParse
#define _Class_ WIParse__
@implementation WIParse

@synthesize __owner_context=__owner_context;
@synthesize debugAutorelease=debugAutorelease;
@synthesize isZombie=isZombie;
@synthesize objectIDInClass=objectIDInClass;
@synthesize objectIDInTotal=objectIDInTotal;
-(void)_startObjectOfClassWIParse {MSGSTART("WIParse:-(void)_startObjectOfClassWIParse")
  
  /*i-996*/debugAutorelease=YES;
  /*i-995*/objInitFn(self,objectIDInTotal,objectIDInClass);
      
  /*i0*/[Singletons._ files];

        ((id<ParseClass>)Parse.class).rulesFilename=@"/Users/Will/mycode/Minim/Parse/rules_wi.txt";


    

}
-(constchar*)cdescription {MSGSTART("WIParse:-(constchar*)cdescription")
  return([self.description cStringUsingEncoding:NSASCIIStringEncoding]);}
-(constchar*)cobjectName {MSGSTART("WIParse:-(constchar*)cobjectName")
  return([self.objectName cStringUsingEncoding:NSASCIIStringEncoding]);}
-(void)dealloc {MSGSTART("WIParse:-(void)dealloc")
  
  /*i-151*/[self die];
/*i998*/deallocFn(self,objectIDInTotal,objectIDInClass);
        isZombie=YES;
#if defined(LONGLIVEZOMBIES) || defined(LONGLIVEZOMBIES___WI_CLASS__)
        if (YES) return;
#endif
    
/*i999*/}
-(NSString*)description {MSGSTART("WIParse:-(NSString*)description")
  
  /*i-999*/NSMutableString *ret=self.objectName;
          
  /*i999*/return(ret);
    }
-(void)die {MSGSTART("WIParse:-(void)die")
  
  /*i900*/}
-(WIParse*)init {MSGSTART("WIParse:-(WIParse*)init")
  
  /*i-10001*/if (!(self=[super init])) return(nil);
  
  /*i11*/[self _startObjectOfClassWIParse];

/*i10001*/return(self);}
-(NSMutableString*)objectName {MSGSTART("WIParse:-(NSMutableString*)objectName")
  
  /*i-999*/NSMutableString *ret=nil;
          
  /*i-100*/ret=[NSMutableString stringWithFormat:@"[%qu:%p]%s#%qu",objectIDInTotal,self,__Derived_CClass__,objectIDInClass];
          
  /*i999*/return(ret);
    }
+(void)substituteStrings:(NSMutableArray*)tokens {MSGSTART("WIParse:+(void)substituteStrings:(NSMutableArray*)tokens")
  for (Token *token in tokens) {
                if ([token.ruleName isEqualToString:@"substituteString"]) {
                      NSError *err=nil;
                      NSString *contents=[token.contents replaceEnvironmentVariables_error:&err];
                      if (!err) {
                            token.contents=contents;
                            token.ruleName=@"string";
                            [token.children removeAllObjects];
                        }
                  }
                [self substituteStrings:token.children];
            }
}
-(WIFile*)wiFileFromFile:(NSString*)path {MSGSTART("WIParse:-(WIFile*)wiFileFromFile:(NSString*)path")
  path=[Singletons._.files pathForPath:path];
          NSError *err = nil;
          NSString *body=nil;
          NSMutableArray *tokens=[Parse getTokensForFile:path options:ParseOptions_evenUnchanged retForString:&body].mutableCopy;
          if (tokens) {
                bool isEmpty=((tokens.count==1)&&[[tokens[0] ruleName] isEqualToString:@"file"]);
                bool hasError=!(isEmpty||((tokens.count==1)&&[[tokens[0] ruleName] isEqualToString:@"par"]&&[[[(Token*)tokens[0] children][0] ruleName] isEqualToString:@"file"]));

                if (!hasError) {
                      if (isEmpty) tokens=@[].mutableCopy;
                      else {
                            Token *t = [(Token *)tokens[0] children][1];
                            NSArray *ch = ([t.ruleName isEqualToString:@"sib"] ? t.children : @[t]);
                            tokens = ch.mutableCopy;
                        }
                  }


                [WIParse substituteStrings:tokens];
                NSString *htmlfn=[path stringByAppendingString:@".parse.html"];
                [[NSFileManager defaultManager] removeItemAtPath:htmlfn error:&err];

                if (hasError) {
                      NSLog(@"%@: %@",path,tokens.description);
                  }

                WIFile *file=[WIFile new];
                [file process:tokens];
                //if (hasError) {
                    NSDictionary *d=@{
                          @"prog":body,
                          @"graph":[Parse graphFromTokens:tokens],
                          @"parsedgraph":file.asD3Tree
                      };
                    NSString *json=[[NSString alloc] initWithData:[NSJSONSerialization dataWithJSONObject:d options:0 error:&err] encoding:NSUTF8StringEncoding];
                    NSString *html=[NSString stringWithContentsOfFile:@"/Users/Will/mycode/Minim/Parse/index.html" encoding:NSUTF8StringEncoding error:&err];
                    html=[html stringByReplacingOccurrencesOfString:@"\"JSONDATA\"" withString:json];
                    [html writeToFile:htmlfn atomically:YES encoding:NSUTF8StringEncoding error:&err];
                    [Singletons._.htmlParseOutput appendFormat:@"<a href='file:%@'>%@</a><br/>",htmlfn,path];
                //}
                return(file);
            }
          else return [WIFile new];
}

@end
#undef _ClassName_
#undef _WIClass_
#undef _className_
#undef _Class_


















#endif // INCLUDE_IFACE
