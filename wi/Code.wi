WIFile
    -(init)init {}

WICtxt
    -(init)init {}

WIClass
    -(init)init {}
    WIFile file={return(self.context.file);}

WIVarContext
    -(init)init {}
    WIFile file={return(self.clazz.context.file);}
WIType
    -(init)init {}
    WIFile file={return(self.clazz.context.file);}

WIVar
    -(init)init {}
    WIFile file={return(self.context.clazz.context.file);}

WIVarArg
    -(init)init {}
    WIFile file={return(self.var.context.clazz.context.file);}

WIBody
    -(init)init {}

WIBodySnippet
    -(init)init {}



TokenHelper
    +(Token*)actualToken:(Token*)token {
        return([self actualToken:token havingRuleIn:nil]);
    }

    +(Token*)actualToken:(Token*)token havingRuleIn:(NSArray*)ruleNames {
        while ([token.ruleName isEqualToString:@"par"]) token=token.children[0];
        return(ruleNames&&![ruleNames containsObject:token.ruleName]?nil:token);
    }

    +(NSArray*)childrenForToken:(Token*)token {
        return([self childrenForToken:token havingRuleIn:nil]);
    }

    +(NSArray*)childrenForToken:(Token*)token havingRuleIn:(NSArray*)ruleNames {
        if (![self actualToken:token havingRuleIn:ruleNames]) return(nil);
        else if ([token.ruleName isEqualToString:@"par"]) {
            Token *par=token.children[0];
            NSMutableArray *chs=[token.children subarrayWithRange:NSMakeRange(1,token.children.count-1)].mutableCopy;
            while ([par.ruleName isEqualToString:@"par"]) {
                [chs addObjectsFromArray:[par.children subarrayWithRange:NSMakeRange(1,par.children.count-1)]];
                par=par.children[0];
            }
            for (int i=0;i<chs.count;i++) {
                while ((i<chs.count)&&[((Token*)chs[i]).ruleName isEqualToString:@"sib"]) {
                    [chs replaceObjectsInRange:NSMakeRange(i,1) withObjectsFromArray:((Token*)chs[i]).children];
                }
            }
            return(chs);
        }
        else return(token.children);
    }

    +(bool)isJustSetting:(Token*)token {
        if ([@[@"class",@"classwprotocol",@"protocol",@"var",@"fn"] containsObject:token.ruleName]) return(NO);
        for (Token *ch in token.children) if (![self isJustSetting:ch]) return(NO);
        return(YES);
    }

    +(NSDictionary*)settingDictionaryForToken:(Token*)token addTo:(NSMutableDictionary*)ret {
        if (!ret) ret=@{}.mutableCopy;
        Token *t=[TokenHelper actualToken:token];
        NSString *setting=t.contents;
        NSMutableDictionary *chrets=ret[setting];
        if (!chrets) ret[setting]=chrets=@{}.mutableCopy;

        if (t!=token) {
            NSArray *chs=[TokenHelper childrenForToken:token];
            for (Token *ch in chs) [self settingDictionaryForToken:ch addTo:chrets];
        }
        return(ret);
    }


<Treeable>
    NSSet treePropertyNames={@-999 static NSSet *retSet=nil;@-100 if (!retSet) {NSArray *ret=nil;@100 retSet=[NSSet setWithArray:ret?ret:@[]];}@999 return(retSet);}
    NSSet treeSingleNodePropertyNames={@-999 static NSSet *retSet=nil;@-100 if (!retSet) {NSArray *ret=nil;@100 retSet=[NSSet setWithArray:ret?ret:@[]];}@999 return(retSet);}
    NSDictionary treeNodeData={@-999 NSDictionary *ret=nil;@999 return(ret?ret:@{});}
    NSDictionary seenTreeNodeData={@-999 NSDictionary *ret=nil;@999 return(ret?ret:self.treeNodeData);}
    NSDictionary asTree={return([self asTree:NSMutableSet.set]);}
    -(NSMutableDictionary*)asTree:(NSMutableSet*)seen {
        return(([Treeable asTree:seen object:self]));
    }

    NSString asD3TreeJSON={
        NSError *err=nil;
        return([[NSString alloc] initWithData:[NSJSONSerialization dataWithJSONObject:self.asD3Tree options:0 error:&err] encoding:NSUTF8StringEncoding]);
    }

    NSDictionary asD3Tree={return([Treeable asD3Tree:self.asTree]);}

Treeable
    +(NSMutableDictionary*)asD3Tree:(NSObject*)dictOrArray {
        NSMutableArray *chs=@[].mutableCopy;
        NSMutableDictionary *ret=@{
            @"name":@"",
            @"linkname":@"",
            @"colour":@"black"
        }.mutableCopy;
        bool term=YES;


        if ([dictOrArray isKindOfClass:NSArray.class]) {
            term=NO;
            for (NSDictionary *d in (NSArray*)dictOrArray) {
                [chs addObject:[self asD3Tree:d]];
            }
            ret[@"colour"]=@"green";
        }
        else if ([dictOrArray isKindOfClass:NSDictionary.class]) {
            NSDictionary *dict=(NSDictionary*)dictOrArray;
            NSArray *names=[dict.allKeys sortedArrayUsingSelector:@selector(caseInsensitiveCompare:)];
            for (NSString *name in names) if (!([name isEqualToString:@"nodedata"])) {
                if ([name isEqualToString:@"collapsed"]) {
                    ret[name]=dict[name];
                }
                else {
                    term=NO;
                    NSMutableDictionary *ch=[self asD3Tree:dict[name]];
                    if (!([name hasPrefix:@" no linkname "]||[ch[@"name"] isEqualToString:name])) ch[@"linkname"]=name;
                    //if (!([name hasPrefix:@" no linkname "]||![ch[@"name"] length])) ch[@"name"]=name;
                    [chs addObject:ch];
                }
            }
            else {
                NSDictionary *data=dict[name];
                if (data[@"name"]) ret[@"name"]=[data[@"name"] jsonString];
                if (data[@"collapsed"]) ret[@"collapsed"]=data[@"collapsed"];
                if (data[@"colour"]) ret[@"colour"]=data[@"colour"];
                else if (data[@"type"]) {
                    switch ([@[@"File",@"Context",@"Class",@"Protocol",@"Type",@"VarContext",@"Var",@"Body",@"Snippet"] indexOfObject:data[@"type"]]) {
                        case NSNotFound:ret[@"colour"]=@"black";break;
                        case 0:ret[@"colour"]=@"white";break;
                        case 1:ret[@"colour"]=@"gray";break;
                        case 2:ret[@"colour"]=@"red";break;
                        case 3:ret[@"colour"]=@"purple";break;
                        case 4:ret[@"colour"]=@"orange";break;
                        case 5:ret[@"colour"]=@"green";break;
                        case 6:ret[@"colour"]=@"blue";break;
                        case 7:ret[@"colour"]=@"darkviolet";break;
                        case 8:ret[@"colour"]=@"darkviolet";break;
                    }
                }
                for (NSString *key in data) if (!([key isEqualToString:@"name"]||[key isEqualToString:@"colour"]||[key isEqualToString:@"collapsed"]||[key isEqualToString:@"type"])) {
                    NSObject *o=data[key];
                    term=NO;
                    NSMutableDictionary *ch=[self asD3Tree:o];
                    if (!([key hasPrefix:@" no linkname "]||[ch[@"name"] length])) ch[@"name"]=key;
                    else ch[@"linkname"]=key;
                    [chs addObject:ch];
                }
            }
        }
        else {
            ret[@"name"]=dictOrArray.jsonString;
            ret[@"colour"]=@"orange";
        }

        if (!term) ret[@"children"]=chs;
        if (!([ret[@"linkname"] hasPrefix:@" no linkname "]||[ret[@"name"] length])) {
            ret[@"name"]=ret[@"linkname"];
            ret[@"linkname"]=@"";
        }
        ret[@"size"]=@(743*[ret[@"name"] length]/9);
        return(ret);
    }

    +(NSMutableDictionary*)asTree:(NSMutableSet*)seen object:(NSObject<Treeable>*)me {
        NSMutableDictionary *ret=NSMutableDictionary.dictionary;

        if ([seen containsObject:me]) {
            NSDictionary *d=me.seenTreeNodeData;
            NSMutableDictionary *md=@{}.mutableCopy;
            ret[@"nodedata"]=md;
            for (id<NSCopying> k in d) if (![d[k] isKindOfClass:NSNull.class]) md[k]=d[k];
            [ret setObject:@YES forKey:@"collapsed"];
        }
        else {
            [seen addObject:me];
            NSDictionary *d=me.treeNodeData;
            NSMutableDictionary *md=@{}.mutableCopy;
            ret[@"nodedata"]=md;
            for (id<NSCopying> k in d) if (![d[k] isKindOfClass:NSNull.class]) md[k]=d[k];

            for (NSString __strong*name in me.treePropertyNames) {
                bool collapsed=[name hasPrefix:@"__"];
                if (collapsed) name=[name substringFromIndex:@"__".length];
                id res=[me performUnknownSelector:NSSelectorFromString(name)];
                if ([res isKindOfClass:NSNull.class]) continue;
                if ([res isKindOfClass:NSSet.class]||[res isKindOfClass:NSArray.class]) {
                    if ([(NSSet*)res count]) {
                        NSMutableArray *chs=NSMutableArray.array;
                        for (NSObject *ch in (NSSet*)res) if ([ch conformsToProtocol:@protocol(Treeable)]) {
                            [chs addObject:[(id<Treeable>)ch asTree:seen]];
                        }
                        else if (![ch isKindOfClass:NSNull.class]) {
                            [chs addObject:ch];
                        }
                        [ret setObject:chs forKey:name];
                    }
                }
                else if ([res isKindOfClass:NSDictionary.class]) {
                    if ([(NSDictionary*)res count]) {
                        NSMutableDictionary *chs=NSMutableDictionary.dictionary;
                        if (collapsed) chs[@"collapsed"]=@YES;
                        for (NSObject<NSCopying> *key in (NSDictionary*)res) {
                            NSObject *ch=((NSDictionary*)res)[key];
                            if ([ch isKindOfClass:NSNull.class]) continue;
                            if ([ch conformsToProtocol:@protocol(Treeable)]) {
                                [chs setObject:[(id<Treeable>)ch asTree:seen] forKey:[@" no linkname " stringByAppendingString:[(id)key jsonString]]];
                            }
                            else {
                                [chs setObject:ch.jsonString forKey:key.jsonString];
                            }
                        }
                        [ret setObject:chs forKey:name];
                    }
                }
                else if ([res conformsToProtocol:@protocol(Treeable)]) {
                    NSMutableDictionary *chd=[(id<Treeable>)res asTree:seen];
                    if (collapsed) chd[@"collapsed"]=@YES;
                    [ret setObject:chd forKey:[@"" stringByAppendingString:name]];
                }
            }

            for (NSString __strong*name in me.treeSingleNodePropertyNames) {
                bool collapsed=[name hasPrefix:@"__"];
                if (collapsed) name=[name substringFromIndex:@"__".length];
                id res=[me performUnknownSelector:NSSelectorFromString(name)];
                if ([res isKindOfClass:NSNull.class]) continue;
                if ([res isKindOfClass:NSSet.class]||[res isKindOfClass:NSArray.class]) {
                    if ([(NSSet*)res count]) {
                        NSMutableArray *chs=NSMutableArray.array;
                        for (NSObject *ch in (NSSet*)res) if ([ch conformsToProtocol:@protocol(Treeable)]) {
                            [chs addObject:@{@"nodedata":((id<Treeable>)ch).seenTreeNodeData}];
                        }
                        else if (![ch isKindOfClass:NSNull.class]) {
                            [chs addObject:ch];
                        }
                        [ret setObject:chs forKey:name];
                    }
                }
                else if ([res isKindOfClass:NSDictionary.class]) {
                    if ([(NSDictionary*)res count]) {
                        NSMutableDictionary *chs=NSMutableDictionary.dictionary;
                        for (NSObject<NSCopying> *key in (NSDictionary*)res) {
                            NSObject *ch=((NSDictionary*)res)[key];
                            if ([ch isKindOfClass:NSNull.class]) continue;
                            if ([ch conformsToProtocol:@protocol(Treeable)]) {
                                [chs setObject:@{@"nodedata":((id<Treeable>)ch).seenTreeNodeData} forKey:[@" no linkname " stringByAppendingString:key.jsonString]];
                            }
                            else {
                                [chs setObject:ch.jsonString forKey:key.jsonString];
                            }
                        }
                        [ret setObject:chs forKey:name];
                    }
                }
                else if ([res conformsToProtocol:@protocol(Treeable)]) {
                    [ret setObject:@{@"nodedata":((id<Treeable>)res).seenTreeNodeData} forKey:[@"" stringByAppendingString:name]];
                }
            }
        }
        return(ret);
    }


WIFile<Treeable>
    NSSet treePropertyNames={ret=@[@"includes",@"ctxts",@"settings"];}
    NSDictionary treeNodeData={ret=@{@"type":@"File"};}

WICtxt<Treeable>
    NSSet treePropertyNames={ret=@[@"clazzs",@"protocols"];}
    NSDictionary treeNodeData={ret=@{
        @"type":@"Context",
        @"name":[(id)self.keyInFile jsonString],
        @"data":self.keyInFile};}

WIClass<Treeable>
    NSSet treePropertyNames={ret=@[@"varCtxts",@"types",@"__settings"];}
    NSSet treeSingleNodePropertyNames={ret=@[@"superclasss",@"conformedProtocols",@"superprotocols"];}
    NSDictionary treeNodeData={ret=@{
        @"collapsed":@YES,
        @"type":(self.classInCtxt?@"Class":@"Protocol"),
        @"name":self.name,
        @"data":@{
            @"collapsed":@YES,
            @"path":@[
                [(id)self.context.keyInFile jsonString],
                self.classInCtxt?self.name:[NSString stringWithFormat:@"<%@>",self.name]
            ]
        }
    };}
    NSString descriptiveName={
        return([(NSDictionary*)self.context.keyInFile count]?
            (self.settings.count?
                [NSString stringWithFormat:@"%@ %@ =>(%@)",self.name,self.settings.jsonString,[(id)self.context.keyInFile jsonString]]:
                [NSString stringWithFormat:@"%@ =>(%@)",self.name,[(id)self.context.keyInFile jsonString]]
            ):
            ([(NSDictionary*)self.settings count]?
                [NSString stringWithFormat:@"%@ %@",self.name,self.settings.jsonString]:
                [NSString stringWithFormat:@"%@",self.name]
            )
        );
    }

WIVarContext<Treeable>
    NSSet treePropertyNames={ret=@[@"vars"];}
    NSDictionary treeNodeData={ret=@{
        @"type":@"VarContext",
        @"name":[(id)self.keyInClazz jsonString],
        @"data":@{
            @"collapsed":@YES,
            @"path":@[
                [(id)self.clazz.context.keyInFile jsonString],
                self.clazz.classInCtxt?self.clazz.name:[NSString stringWithFormat:@"<%@>",self.clazz.name],
                [(id)self.keyInClazz jsonString]
            ]
        }
    };}
    NSDictionary seenTreeNodeData={ret=@{
        @"type":@"VarContext",
        @"name":self.descriptiveName,
        @"data":@{
            @"collapsed":@YES,
            @"path":@[
                [(id)self.clazz.context.keyInFile jsonString],
                self.clazz.classInCtxt?self.clazz.name:[NSString stringWithFormat:@"<%@>",self.clazz.name],
                [(id)self.keyInClazz jsonString]
            ]
        }
    };}
    NSString descriptiveName={
        return([(NSDictionary*)self.clazz.context.keyInFile count]?
            ([(NSDictionary*)self.keyInClazz count]?
                [NSString stringWithFormat:@"%@ %@ =>(%@)",self.clazz.name,[(id)self.keyInClazz jsonString],[(id)self.clazz.context.keyInFile jsonString]]:
                [NSString stringWithFormat:@"%@ =>(%@)",self.clazz.name,[(id)self.clazz.context.keyInFile jsonString]]
            ):
            ([(NSDictionary*)self.keyInClazz count]?
                [NSString stringWithFormat:@"%@ %@",self.clazz.name,[(id)self.keyInClazz jsonString]]:
                [NSString stringWithFormat:@"%@",self.clazz.name]
            )
        );
    }

WIType<Treeable>
    NSDictionary treeNodeData={ret=@{
        @"collapsed":@YES,
        @"type":@"Type",
        @"name":[(id)self.keyInClazz jsonString],
    };}// TODO json
    NSDictionary seenTreeNodeData={ret=@{
        @"type":@"Type",
        @"name":self.descriptiveName,
    };}
    NSString descriptiveName={
        return([(NSDictionary*)self.clazz.context.keyInFile count]?
            ([(NSArray*)self.keyInClazz count]?
                [NSString stringWithFormat:@"%@ %@ =>(%@)",self.clazz.name,[(id)self.keyInClazz jsonString],[(id)self.clazz.context.keyInFile jsonString]]:
                [NSString stringWithFormat:@"%@ =>(%@)",self.clazz.name,[(id)self.clazz.context.keyInFile jsonString]]
            ):
            ([(NSArray*)self.keyInClazz count]?
                [NSString stringWithFormat:@"%@ %@",self.clazz.name,[(id)self.keyInClazz jsonString]]:
                [NSString stringWithFormat:@"%@",self.clazz.name]
            )
        );
    }


WIVar<Treeable>
    NSSet treePropertyNames={ret=@[@"getter",@"setters",@"defaultValue",@"atomicVars",@"__settings"];}
    NSDictionary treeNodeData={ret=@{
        @"type":@"Var",
        @"name":self.boundTo?
            [([(NSDictionary*)self.settings count]?
                [NSString stringWithFormat:@"%@ %@",self.selectorString,self.settings.jsonString]:
                [NSString stringWithFormat:@"%@",self.selectorString]
            )
            stringByAppendingFormat:@" %@ %@",
                self.bindingType,self.boundTo.descriptiveName]:
            ([(NSDictionary*)self.settings count]?
                [NSString stringWithFormat:@"%@ %@",self.selectorString,self.settings.jsonString]:
                [NSString stringWithFormat:@"%@",self.selectorString]
            ),
        @"binding":(self.boundTo?
            @{self.bindingType:self.boundTo.descriptiveName}:
            NSNull.null
        ),
        @"data":@{
            @"collapsed":@YES,
            @"path":@[
                [(id)self.context.clazz.context.keyInFile jsonString],
                self.context.clazz.classInCtxt?self.context.clazz.name:[NSString stringWithFormat:@"<%@>",self.context.clazz.name],
                [(id)self.context.keyInClazz jsonString],
                self.selectorString
            ]
        }
    };}
    NSDictionary seenTreeNodeData={
        ret=@{@"type":@"Var",
            @"name":self.descriptiveName
        };
    }
    NSString descriptiveName={return([NSString stringWithFormat:@"%@::%@",self.context.descriptiveName,self.selectorString]);}
    NSString selectorString={
        NSMutableString *ret=[NSMutableString stringWithFormat:@"(%@)%@",self.type.descriptiveName,self.name];
        for (WIVarArg *arg in self.args) {
            [ret appendFormat:@"%@:(%@)%@",
                arg.arg?[@" " stringByAppendingString:arg.arg]:
                (arg.indexInVar?
                    @" ?":
                    @""
                ),
                arg.type.descriptiveName,
                arg.name?arg.name:@"?"
            ];
        }
        return(ret);
    }

WIBody<Treeable>
    NSSet treePropertyNames={ret=@[];}
    NSDictionary treeNodeData={ret=@{@"type":@"Body",@"name":self.descriptiveName};}
    NSString descriptiveName={
        NSMutableString *ret=@"".mutableCopy;
        NSArray *keys=[self.snippets.allKeys sortedArrayUsingSelector:@selector(compare:)];
        bool fst=YES;
        for (NSObject<NSCopying> *key in keys) {
            [ret appendFormat:(fst?@"@%@ -- %@":@" -- @%@ -- %@"),key,[self.snippets[key] strings].jsonString];
        }
        return(ret);
    }

WIBodySnippet<Treeable>
    NSDictionary treeNodeData={
        ret=@{
            @"type":@"Snippet",
            @"name":[NSString stringWithFormat:@"@%@: %@",[(id)self.keyInBody jsonString],self.strings.jsonString]
        };
    }







WIFile
    -(WICtxt*)contextWithRegexes:(NSArray*)regexes {
        WICtxt *ret=[self ctxtForKey:regexes];
        if (!ret) [self setCtxt:ret=[WICtxt new] forKey:regexes];
        return(ret);
    }

    -(void)process:(NSArray*)tokens {
        NSMutableArray *regexes=NSMutableArray.array;
        NSSet *settings=NSSet.set;
        for (Token *token in tokens) [self process:token regexes:regexes settings:settings];
    }

    -(void)process:(Token*)token regexes:(NSMutableArray*)regexes settings:(NSSet*)settings {
        Token *t=[TokenHelper actualToken:token];
        NSArray *chs;

        if ([TokenHelper actualToken:t havingRuleIn:@[@"class",@"protocol",@"classwprotocol",@"mod"]]) {
            [[self contextWithRegexes:@{}] process:token regexes:regexes.mutableCopy settings:settings outerClass:nil outerLinkType:nil outerLinkVar:nil mods:@[]];
        }
        else if ((chs=[TokenHelper childrenForToken:token havingRuleIn:@[@"file"]])) {
            for (Token *ch in chs) [self process:ch regexes:regexes settings:settings];
        }
        else if ([TokenHelper actualToken:t havingRuleIn:@[@"regex"]]) {
            NSDictionary *re=@{
                ((Token*)t.children[0]).contents:((Token*)t.children[1]).contents
            };
            if (![(NSDictionary*)regexes.lastObject isEqual:re]) {
                [regexes addObject:re];
            }
        }
        else if ((chs=[TokenHelper childrenForToken:token havingRuleIn:@[@"setting"]])) {
            NSString *setting=((Token*)t.children[0]).contents;
            if ([token.ruleName isEqualToString:@"setting"]) {
                [self.includesSet appendObject:setting];
            }
            else if ([TokenHelper isJustSetting:token]) {
                [TokenHelper settingDictionaryForToken:token addTo:self.settings];
            }
            else {
                for (Token *ch in chs) [self process:ch regexes:regexes settings:[settings setByAddingObject:setting]];
            }
        }
    }

WICtxt
    -(WIClass*)classWithName:(NSString*)name {
        WIClass *ret=[self clazzForKey:name];
        if (!ret) [self setClazz:ret=[WIClass new] forKey:name];
        return(ret);
    }
    -(WIClass*)protocolWithName:(NSString*)name {
        WIClass *ret=[self protocolForKey:name];
        if (!ret) [self setProtocol:ret=[WIClass new] forKey:name];
        return(ret);
    }

    -(void)process:(Token*)token regexes:(NSMutableArray*)regexes settings:(NSSet*)settings outerClass:(WIClass*)outerClass outerLinkType:(NSString*)outerLinkType outerLinkVar:(WIVar*)outerLinkVar mods:(NSArray*)mods {
        Token *t=[TokenHelper actualToken:token];
        NSArray *chs;
        bool doingInitialSettings=YES;

        if ((chs=[TokenHelper childrenForToken:token havingRuleIn:@[@"mod"]])) {
            NSMutableArray *newMods=@[].mutableCopy;
            for (Token *ch in chs) if (![TokenHelper actualToken:ch havingRuleIn:@[@"class",@"protocol",@"classwprotocol"]]) {
                [newMods addObject:ch.contents];
            }
            for (Token *ch in chs) if ([TokenHelper actualToken:ch havingRuleIn:@[@"class",@"protocol",@"classwprotocol"]]) {
                [self process:ch regexes:regexes settings:settings outerClass:outerClass outerLinkType:outerLinkType outerLinkVar:outerLinkVar mods:newMods];
            }
        }
        else if ((chs=[TokenHelper childrenForToken:token havingRuleIn:@[@"class"]])) {
            NSString *name=((Token*)t.children[0]).contents;
            NSString *sup=(t.children.count==1?nil:((Token*)t.children[1]).contents);
            WIClass *clazz=[self classWithName:name];
            if (sup) [clazz addSuperclass:[self classWithName:sup]];

            if (t==token) {
                NSMutableDictionary *settingMods=clazz.settings[@"mods"];
                if (![settingMods isKindOfClass:NSMutableDictionary.class]) clazz.settings[@"mods"]=settingMods=NSMutableDictionary.dictionary;
                for (NSString *mod in mods) [settingMods setObject:NSMutableDictionary.dictionary forKey:mod];
            }
            else {
                for (Token *ch in chs) [clazz process:ch regexes:regexes settings:settings doingInitialSettings:doingInitialSettings outerClass:outerClass outerLinkType:outerLinkType outerLinkVar:outerLinkVar mods:mods];
            }
        }
        else if ((chs=[TokenHelper childrenForToken:token havingRuleIn:@[@"protocol"]])) {
            NSString *name=((Token*)t.children[0]).contents;
            WIClass *protocol=[self protocolWithName:name];
            int index=-1;
            for (Token *pt in t.children) if (++index) [protocol addSuperprotocol:[self protocolWithName:pt.contents]];

            if (t==token) {
                NSMutableDictionary *settingMods=protocol.settings[@"mods"];
                if (![settingMods isKindOfClass:NSMutableSet.class]) protocol.settings[@"mods"]=settingMods=NSMutableDictionary.dictionary;
                for (NSString *mod in mods) [settingMods setObject:NSMutableDictionary.dictionary forKey:mod];
            }
            else {
                for (Token *ch in chs) [protocol process:ch regexes:regexes settings:settings doingInitialSettings:doingInitialSettings outerClass:outerClass outerLinkType:outerLinkType outerLinkVar:outerLinkVar mods:mods];
            }
        }
        else if ((chs=[TokenHelper childrenForToken:token havingRuleIn:@[@"classwprotocol"]])) {
            Token *classt=t.children[0];
            Token *protocolt=t.children[1];

            NSString *name=((Token*)classt.children[0]).contents;
            NSString *sup=(classt.children.count==1?nil:((Token*)classt.children[1]).contents);


            WIClass *clazz=[self classWithName:name];
            if (sup) [clazz addSuperclass:[self classWithName:sup]];
            for (Token *pt in protocolt.children) [clazz addConformedProtocol:[self protocolWithName:pt.contents]];

            if (t==token) {
                NSMutableDictionary *settingMods=clazz.settings[@"mods"];
                if (![settingMods isKindOfClass:NSMutableDictionary.class]) clazz.settings[@"mods"]=settingMods=NSMutableDictionary.dictionary;
                for (NSString *mod in mods) [settingMods setObject:NSMutableDictionary.dictionary forKey:mod];
            }
            else {
                for (Token *ch in chs) [clazz process:ch regexes:regexes settings:settings doingInitialSettings:doingInitialSettings outerClass:outerClass outerLinkType:outerLinkType outerLinkVar:outerLinkVar mods:mods];
            }
        }
    }



WIClass
    -(WIVarContext*)varCtxtWithSettings:(NSSet*)settings {
        WIVarContext *ret=[self varCtxtForKey:settings];
        if (!ret) [self setVarCtxt:ret=[WIVarContext new] forKey:settings];
        return(ret);
    }
    -(WIType*)typeWithModifiers:(NSArray*)mods {
        WIType *ret=[self typeForKey:mods];
        if (!ret) [self setType:ret=[WIType new] forKey:mods];
        return(ret);
    }

    WICtxt context={return(self.classInCtxt?self.classInCtxt:self.protocolInCtxt);}
    NSString name={return(NSString*)(self.classInCtxt?self.keyInClassInCtxt:self.keyInProtocolInCtxt);}

    -(void)process:(Token*)token regexes:(NSMutableArray*)regexes settings:(NSSet*)settings doingInitialSettings:(bool&)doingInitialSettings outerClass:(WIClass*)outerClass outerLinkType:(NSString*)outerLinkType outerLinkVar:(WIVar*)outerLinkVar mods:(NSArray*)mods {
        Token *t=[TokenHelper actualToken:token];
        NSArray *chs;

        if ((chs=[TokenHelper childrenForToken:token havingRuleIn:@[@"setting"]])) {
            if (doingInitialSettings&&[TokenHelper isJustSetting:token]) {
                [TokenHelper settingDictionaryForToken:token addTo:self.settings];
            }
            else {
                NSSet *newSettings=[settings setByAddingObject:((Token*)t.children[0]).contents];
                doingInitialSettings=NO;
                for (Token *ch in chs) [self process:ch regexes:regexes settings:newSettings doingInitialSettings:doingInitialSettings outerClass:outerClass outerLinkType:outerLinkType outerLinkVar:outerLinkVar mods:mods];
            }
        }
        else if ([TokenHelper actualToken:t havingRuleIn:@[@"class",@"protocol",@"classwprotocol",@"mod"]]) {
            [[self.context.file contextWithRegexes:regexes] process:token regexes:regexes.mutableCopy settings:settings outerClass:self outerLinkType:nil outerLinkVar:nil mods:@[]];
        }
        else if ([TokenHelper actualToken:t havingRuleIn:@[@"regex"]]) {
            [regexes setObject:((Token*)t.children[1]).contents forKey:((Token*)t.children[0]).contents];
        }
        else if (outerClass&&((chs=[TokenHelper childrenForToken:token havingRuleIn:@[@"var",@"fn"]]))) {
            WIVarContext *varCtxt=[outerClass varCtxtWithSettings:settings];
            WIVar *var=[varCtxt varForVarToken:t type:[self typeWithModifiers:mods] regexes:regexes];

            bool varDoingInitialSettings=YES;
            NSMutableDictionary *newRegexes=regexes.mutableCopy;
            for (Token *ch in chs) {
                [var process:ch regexes:newRegexes settings:settings doingInitialSettings:varDoingInitialSettings];
            }
        }
    }



WIVarContext
    -(WIType*)typeForFnBlock:(Token*)token mods:(NSMutableArray*)mods regexes:(NSMutableArray*)regexes {
        Token *typet=token.children[0],*classt=typet;
        NSMutableArray *mods2=@[].mutableCopy;
        if ([typet.ruleName isEqualToString:@"mod"]) {
            for (Token *ch2 in typet.children) if (![TokenHelper actualToken:ch2 havingRuleIn:@[@"class",@"protocol",@"classwprotocol"]]) {
                [mods2 addObject:ch2.contents];
            }
            else classt=ch2;
        }
        WICtxt *ctxt=[self.clazz.context.file contextWithRegexes:regexes];
        NSString *className=nil,*protocolName=nil;
        if ([classt.ruleName isEqualToString:@"class"]) className=((Token*)classt.children[0]).contents;
        else if ([classt.ruleName isEqualToString:@"classwprotocol"]) className=((Token*)((Token*)classt.children[0]).children[0]).contents;
        else if ([classt.ruleName isEqualToString:@"protocol"]) protocolName=((Token*)classt.children[0]).contents;

        WIClass *clazz=(className?[ctxt classWithName:className]:[ctxt protocolWithName:protocolName]);

        NSMutableArray *key=@[].mutableCopy;
        [key addObject:((Token*)token.children[1]).contents];

        [self _addArgsFromToken:token key:key argTypes:nil argArgs:nil argNames:nil regexes:regexes];
        [mods2 addObject:key];
        [mods addObject:mods2];
        return([clazz typeWithModifiers:mods]);
    }

    -(WIVar*)varWithVarKey:(NSArray*)key {
        WIVar *var=[self varForKey:key];
        if (!var) {
            [self setVar:var=[WIVar new] forKey:key];

            var.name=(NSString*)key[0];
            WICtxt *ctxt=self.clazz.context;
            WIClass *c=([key[1] isKindOfClass:NSString.class]?
                [ctxt classWithName:key[1]]:
                [ctxt protocolWithName:((NSArray*)key[2])[0]]
            );
            var.type=[c typeWithModifiers:(NSArray*)key[3]];
            for (int i=4;i<key.count;i++) {
                WIVarArg *arg=[WIVarArg new];
                NSArray *argKey=key[i];

                arg.name=(NSString*)argKey[0];
                arg.arg=(NSString*)argKey[1];
                WIClass *c=([argKey[2] isKindOfClass:NSString.class]?
                    [ctxt classWithName:argKey[2]]:
                    [ctxt protocolWithName:((NSArray*)argKey[3])[0]]
                );
                arg.type=[c typeWithModifiers:(NSArray*)argKey[4]];

                [var addArg:arg];
            }
        }
        return(var);
    }

    -(WIVar*)varForVarToken:(Token*)token type:(WIType*)type regexes:(NSMutableArray*)regexes {
        NSString *name=((Token*)token.children[0]).contents;
        NSMutableArray *key=@[
            name,
            type.clazz.classInCtxt?type.clazz.name:NSNull.null,
            type.clazz.protocolInCtxt?@[type.clazz.name]:NSNull.null,
            type.keyInClazz
        ].mutableCopy;
        NSMutableArray *argTypes=@[].mutableCopy,*argArgs=@[].mutableCopy,*argNames=@[].mutableCopy;

        [self _addArgsFromToken:token key:key argTypes:argTypes argArgs:argArgs argNames:argNames regexes:regexes];

        WIVar *var=[self varForKey:key];
        if (!var) {
            [self setVar:var=[WIVar new] forKey:key];
            var.type=type;
            var.name=name;
            for (int i=0;i<argTypes.count;i++) {
                WIVarArg *arg=[WIVarArg new];
                arg.type=argTypes[i];
                if ([argNames[i] isKindOfClass:NSString.class]) arg.name=argNames[i];
                if ([argArgs[i] isKindOfClass:NSString.class]) arg.arg=argArgs[i];
                [var addArg:arg];
            }
        }
        return(var);
    }

    -(void)_addArgsFromToken:(Token*)token key:(NSMutableArray*)key argTypes:(NSMutableArray*)argTypes argArgs:(NSMutableArray*)argArgs argNames:(NSMutableArray*)argNames regexes:(NSMutableArray*)regexes {
        for (Token *t in token.children) {
            if ([t.ruleName isEqualToString:@"argList"]||[t.ruleName isEqualToString:@"selArgList"]) {
                [self _addArgsFromToken:t key:key argTypes:argTypes argArgs:argArgs argNames:argNames regexes:regexes];
            }
            else {
                int nameArg=-1,argArg=-1,typeArg=-1;
                if ([t.ruleName isEqualToString:@"selArgDef"]) {
                    switch (t.children.count) {
                        case 1: argArg=-1;nameArg=-1;typeArg=0;break;
                        case 2: argArg=-1;nameArg=1;typeArg=0;break;
                        case 3: argArg=0;nameArg=2;typeArg=1;break;
                    }
                }
                else if ([t.ruleName isEqualToString:@"argDef"]) {
                    switch (t.children.count) {
                        case 1: argArg=-1;nameArg=-1;typeArg=0;break;
                        case 2: argArg=-1;nameArg=1;typeArg=0;break;
                    }
                }
                else continue;


                NSString *name=(nameArg==-1?nil:((Token*)t.children[nameArg]).contents);
                NSString *arg=(argArg==-1?nil:((Token*)t.children[argArg]).contents);

                Token *typet=t.children[typeArg],*classt=typet;
                NSMutableArray *mods=@[].mutableCopy;
                if ([typet.ruleName isEqualToString:@"mod"]) {
                    for (Token *ch2 in typet.children) if (![TokenHelper actualToken:ch2 havingRuleIn:@[@"class",@"protocol",@"classwprotocol"]]) {
                        [mods addObject:ch2.contents];
                    }
                    else classt=ch2;
                }
                WICtxt *ctxt=[self.clazz.context.file contextWithRegexes:regexes];
                NSString *className=nil,*protocolName=nil;
                if ([classt.ruleName isEqualToString:@"class"]) className=((Token*)classt.children[0]).contents;
                else if ([classt.ruleName isEqualToString:@"classwprotocol"]) className=((Token*)((Token*)classt.children[0]).children[0]).contents;
                else if ([classt.ruleName isEqualToString:@"protocol"]) protocolName=((Token*)classt.children[0]).contents;

                WIType *argType;
                if ([classt.ruleName isEqualToString:@"fnblock"]) {
                    argType=[self typeForFnBlock:classt mods:mods regexes:regexes];
                }
                else {
                    WIClass *clazz=(className?[ctxt classWithName:className]:[ctxt protocolWithName:protocolName]);
                    argType=[clazz typeWithModifiers:mods];
                }

                [key addObject:@[
                    name?name:NSNull.null,
                    arg?arg:NSNull.null,
                    className?className:NSNull.null,
                    protocolName?@[protocolName]:NSNull.null,// TODO
                    mods
                ]];

                [argTypes addObject:argType];
                [argNames addObject:name?name:NSNull.null];
                [argArgs addObject:arg?arg:NSNull.null];
            }
        }
    }




WIVar
    +(NSArray*)keyWithType:(WIType*)type name:(NSString*)name args:(NSArray*)args {
        NSMutableArray *key=@[
            name,
            type.clazz.classInCtxt?type.clazz.name:NSNull.null,
            type.clazz.protocolInCtxt?@[type.clazz.name]:NSNull.null,
            type.keyInClazz
        ].mutableCopy;
        for (WIVarArg *arg in args) {
            NSString *className=type.clazz.keyInClassInCtxt;
            NSString *protocolName=type.clazz.keyInProtocolInCtxt;
            NSArray *mods=type.keyInClazz;
            [key addObject:@[
                arg.name?arg.name:NSNull.null,
                arg.arg?arg.arg:NSNull.null,
                className?className:NSNull.null,
                protocolName?@[protocolName]:NSNull.null,// TODO
                mods
            ]];
        }
        return(key);
    }

    -(WIBody*)setterWithSetterVar:(NSString*)setterVar {
        WIBody *body=[self setterForKey:setterVar];
        if (!body) [self setSetter:body=[WIBody new] forKey:setterVar];
        return(body);
    }


    -(void)process:(Token*)token regexes:(NSMutableArray*)regexes settings:(NSSet*)settings doingInitialSettings:(bool&)doingInitialSettings {
        Token *t=[TokenHelper actualToken:token];
        NSArray *chs;

        if ((chs=[TokenHelper childrenForToken:token havingRuleIn:@[@"setting"]])) {
            if (doingInitialSettings&&[TokenHelper isJustSetting:token]) {
                [TokenHelper settingDictionaryForToken:token addTo:self.settings];
            }
            else {
                NSSet *newSettings=[settings setByAddingObject:((Token*)t.children[0]).contents];
                doingInitialSettings=NO;
                for (Token *ch in chs) [self process:ch regexes:regexes settings:newSettings doingInitialSettings:doingInitialSettings];
            }
        }
        else if ([TokenHelper actualToken:t havingRuleIn:@[@"block"]]) {
            WIBody *body=self.getter;
            if (!body) self.getter=body=[WIBody new];
            [body incorporateBody:((Token*)t.children[0]).contents];
        }
        else if ((chs=[TokenHelper childrenForToken:token havingRuleIn:@[@"getter"]])) {
            WIBody *body=self.getter;
            if (!body) self.getter=body=[WIBody new];
            if (chs.count) [body incorporateBody:((Token*)((Token*)chs[0]).children[0]).contents];
        }
        else if ((chs=[TokenHelper childrenForToken:token havingRuleIn:@[@"init"]])) {
            WIBody *body=self.defaultValue;
            if (!body) self.defaultValue=body=[WIBody new];
            if (chs.count) [body incorporateBody:((Token*)((Token*)chs[0]).children[0]).contents];
        }
        else if ((chs=[TokenHelper childrenForToken:token havingRuleIn:@[@"setter"]])) {
            NSString *setterVar=(t.children.count?((Token*)t.children[0]).contents:@"v");
            WIBody *body=[self setterWithSetterVar:setterVar];
            if (chs.count) [body incorporateBody:((Token*)((Token*)chs[0]).children[0]).contents];
        }
        else if ([TokenHelper actualToken:t havingRuleIn:@[@"regex"]]) {
            NSDictionary *re=@{
                ((Token*)t.children[0]).contents:((Token*)t.children[1]).contents
            };
            if (![(NSDictionary*)regexes.lastObject isEqual:re]) {
                [regexes addObject:re];
            }
        }
        else if ((chs=[TokenHelper childrenForToken:token havingRuleIn:@[@"link"]])) {
            NSString *linkType=((Token*)t.children[0]).contents;
            WICtxt *ctxt=[self.context.clazz.context.file contextWithRegexes:regexes];
            NSMutableArray *newRegexes=regexes.mutableCopy;
            for (Token *ch in chs) {
                [ctxt process:ch regexes:newRegexes settings:settings outerClass:nil outerLinkType:linkType outerLinkVar:self mods:@[]];
            }
        }
        else if ((chs=[TokenHelper childrenForToken:token havingRuleIn:@[@"atomic"]])) {
            WIVarContext *varCtxt=[[[self.context.clazz.context.file contextWithRegexes:regexes] classWithName:self.context.clazz.name] varCtxtWithSettings:settings];
            NSMutableArray *newRegexes=regexes.mutableCopy;
            for (Token *ch in chs) {
                [self addAtomicVar:[varCtxt varForVarToken:ch type:self.type regexes:newRegexes]];
            }
        }
    }


WIBody
    -(WIBodySnippet*)snippetAtOrdinal:(int)ordinal {
        WIBodySnippet *ret=[self snippetForKey:@(ordinal)];
        if (!ret) [self setSnippet:ret=[WIBodySnippet new] forKey:@(ordinal)];
        return(ret);
    }

    +(NSRegularExpression*)splitterRegex {
        static NSRegularExpression *ret=nil;
        NSError *err=nil;
        if (!ret) ret=[NSRegularExpression regularExpressionWithPattern:
            @"()@((-?\\d+)?)"
            //@"((?:[^\"\@]*(?:\"(\\\\\\\\|\\\\\"|[^\"])++\")?)*+)\@((?:-?\\d+)?)"
            options:NSRegularExpressionDotMatchesLineSeparators error:&err];
        return(ret);
    }
    -(void)incorporateBody:(NSString*)body {
        NSArray *matches=[self.class.splitterRegex matchesInString:body options:0 range:NSMakeRange(0,body.length)];
        WIBodySnippet *snippet=nil;
        int at=0;
        NSInteger remainder=0;
        for (NSTextCheckingResult *match in matches) {
            remainder=match.range.location+match.range.length;
            NSString *s=[body substringWithRange:[match rangeAtIndex:1]];
            if (snippet||s.length) {
                if (!snippet) snippet=[self snippetAtOrdinal:at];
                [snippet.strings addObject:s];
            }
            if ([match rangeAtIndex:2].length) {
                at=[body substringWithRange:[match rangeAtIndex:2]].intValue;
                snippet=[self snippetAtOrdinal:at];
            }
        }
        if (remainder<body.length) {
            if (!snippet) snippet=[self snippetAtOrdinal:at];
            [snippet.strings addObject:[body substringWithRange:NSMakeRange(remainder,body.length-remainder)]];
        }
    }











