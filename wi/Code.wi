WIFile
    MutableArray includes=[MutableArray array]
    file ~d< WICtxt ctxt // a context can hold classes etc. The key is the regex dictionary

WICtxt
    classInCtxt ~d< WIClass clazz // the classes keyed by name
    protocolInCtxt ~d< WIClass protocol // the protocols keyed by name

WIClass
    MutableDictionary settings=[MutableDictionary dictionary] // a class may start with settings which are collected here
    subclass >s< WIClass superclass
    conformingClass >s< WIClass conformedProtocol
    subprotocol >s< WIClass superprotocol

    clazz -d< WIVarContext varCtxt // each variable belongs to a context, hanging off a class, that configures things like readonly. The key here is the settings as a set
    clazz -d< WIType type  // The various modified forms of this class. The key is the modifiers as an array

WIVarContext
WIType


WIVar
    var >~d- WIVarContext context // each variable belongs to a context, the key is an array : @[name,typeclass,@[typeprotocol],typemods,@[name,arg,typeclass,@[typeprotocol],typemods]]
    var >~s- WIType type // i.e. return type

    NSString name=0
    var ~a< WIVarArg arg
        NSString name=0,arg=0
        arg >~s- WIType type // i.e. arg type

    getterForVar ~- WIBody getter
    defaultValueForVar ~- WIBody defaultValue
    setterForVar ~d< WIBody setter

    MutableDictionary settings=[MutableDictionary dictionary]  // the body of a function may start with settings like 'super' etc..

    WIVar boundTo=0  // linked var
    NSString bindingType=0 // link type

    fluidVar >s< WIVar atomicVar

WIBody
    body ~d< WIBodySnippet snippet

WIBodySnippet
    MutableSet strings=[MutableSet set]



TokenHelper
    +(Token*)actualToken:(Token*)token {
        return([self actualToken:token havingRuleIn:nil]);
    }

    +(Token*)actualToken:(Token*)token havingRuleIn:(NSArray*)ruleNames {
        while ([token.ruleName isEqualToString:@"par"]) token=token.children[0];
        return(ruleNames&&![ruleNames containsObject:token.ruleName]?nil:token);
    }

    +(NSArray*)childrenForToken:(Token*)token {
        return([self childrenForToken:token havingRuleIn:nil]);
    }

    +(NSArray*)childrenForToken:(Token*)token havingRuleIn:(NSArray*)ruleNames {
        if (![self actualToken:token havingRuleIn:ruleNames]) return(nil);
        else if ([token.ruleName isEqualToString:@"par"]) {
            Token *par=token.children[0];
            NSMutableArray *chs=[token.children subarrayWithRange:NSMakeRange(1,token.children.count-1)].mutableCopy;
            while ([par.ruleName isEqualToString:@"par"]) {
                [chs addObjectsFromArray:[par.children subarrayWithRange:NSMakeRange(1,par.children.count-1)]];
                par=par.children[0];
            }
            for (int i=0;i<chs.count;i++) {
                while ((i<chs.count)&&[((Token*)chs[i]).ruleName isEqualToString:@"sib"]) {
                    [chs replaceObjectsInRange:NSMakeRange(i,1) withObjectsFromArray:((Token*)chs[i]).children];
                }
            }
            return(chs);
        }
        else return(@[]);
    }

    +(bool)isJustSetting:(Token*)token {
        if ([@[@"class",@"classwprotocol",@"protocol",@"var",@"fn"] containsObject:token.ruleName]) return(NO);
        for (Token *ch in token.children) if (![self isJustSetting:ch]) return(NO);
        return(YES);
    }

    +(NSDictionary*)settingDictionaryForToken:(Token*)token addTo:(NSMutableDictionary*)ret {
        if (!ret) ret=@{}.mutableCopy;
        NSString *setting=[TokenHelper actualToken:token].contents;
        NSMutableDictionary *chrets=ret[setting];
        if (!chrets) ret[setting]=chrets=@{}.mutableCopy;

        NSArray *chs=[TokenHelper childrenForToken:token];
        for (Token *ch in chs) [self settingDictionaryForToken:ch addTo:chrets];

        return(ret);
    }


<Treeable>
    NSSet treePropertyNames={@-999 static NSSet *retSet=nil;@-100 if (!retSet) {NSArray *ret=nil;@100 retSet=[NSSet setWithArray:ret?ret:@[]];}@999 return(retSet);}
    NSDictionary treeNodeData={@-999 NSDictionary *ret=nil;@999 return(ret?ret:@{});}
    NSDictionary seenTreeNodeData={@-999 NSDictionary *ret=nil;@999 return(ret?ret:self.treeNodeData);}
    NSDictionary asTree={return([self asTree:NSMutableSet.set]);}
    -(NSDictionary*)asTree:(NSMutableSet*)seen {
        NSMutableDictionary *ret=NSMutableDictionary.dictionary;

        if ([seen containsObject:self]) {
            [ret setObject:self.seenTreeNodeData forKey:@"nodedata"];
        }
        else {
            [seen addObject:self];
            [ret setObject:self.treeNodeData forKey:@"nodedata"];

            for (NSString *name in self.treePropertyNames) {
                id res=[self performUnknownSelector:NSSelectorFromString(name)];
                if ([res isKindOfClass:NSSet.class]||[res isKindOfClass:NSArray.class]) {
                    NSMutableArray *chs=NSMutableArray.array;
                    for (NSObject *ch in (NSSet*)res) if ([ch conformsToProtocol:@protocol(Treeable)]) {
                        [chs addObject:[(id<Treeable>)ch asTree:seen]];
                    }
                    [ret setObject:chs forKey:name];
                }
                else if ([res isKindOfClass:NSDictionary.class]) {
                    NSMutableDictionary *chs=NSMutableDictionary.dictionary;
                    for (NSObject<NSCopying> *key in (NSDictionary*)res) {
                        NSObject *ch=((NSDictionary*)res)[key];
                        if ([ch conformsToProtocol:@protocol(Treeable)]) {
                            [chs setObject:[(id<Treeable>)ch asTree:seen] forKey:key];
                        }
                    }
                    [ret setObject:chs forKey:name];
                }
                else if ([res conformsToProtocol:@protocol(Treeable)]) {
                    [ret setObject:[(id<Treeable>)res asTree:seen] forKey:name];
                }
            }
        }
        return(ret);
    }

    NSString asD3TreeJSON={
        NSError *err=nil;
        return([[NSString alloc] initWithData:[NSJSONSerialization dataWithJSONObject:self.asD3Tree options:0 error:&err] encoding:NSUTF8StringEncoding]);
    }

    NSDictionary asD3Tree={return([Treeable asD3Tree:self.asTree]);}
    +(NSMutableDictionary*)asD3Tree:(NSObject*)dictOrArray {
        NSMutableArray *chs=@[].mutableCopy;
        NSMutableDictionary *ret=@{
            @"name":@"",
            @"linkname":@"",
            @"color":@"black"
        }.mutableCopy;
        bool term=YES;


        if ([dictOrArray isKindOfClass:NSArray.class]) {
            term=NO;
            for (NSDictionary *d in (NSArray*)dictOrArray) {
                [chs addObject:[self asD3Tree:d]];
                [chs2 addObject:ch];
            }
            ret[@"color"]=@"green";
        }
        else {
            NSDictionary *dict=(NSDictionary*)dictOrArray;
            for (NSString *name in dict) if (!([name isEqualToString:@"nodedata"])) {
                term=NO;
                NSMutableDictionary *ch=[self asD3Tree:dict[name]];
                ch[@"linkname"]=name;
                [chs addObject:ch];
            }
            else {
                NSDictionary *data=dict[name];
                if (data[@"name"]) ret[@"name"]=data[@"name"];
                if (data[@"color"]) ret[@"color"]=data[@"color"];
                for (NSString *key in data) if (!([key isEqualToString:@"name"]||[key isEqualToString:@"color"])) {
                    NSObject *o=data[key];
                    term=NO;
                    if ([o isKindOfClass:NSArray.class]||[o isKindOfClass:NSDictionary.class]) {
                        NSMutableDictionary *ch=[self asD3Tree:o];
                        ch[@"linkname"]=key;
                        [chs addObject:ch];
                    }
                    else {
                        [chs addObject:@{
                            @"name":o.description,
                            @"linkname":key,
                            @"size":@(743*o.description.length/9),
                            @"color":@"orange"
                        }];
                    }
                }
            }
        }
        if (!term) ret[@"children"]=chs;
        ret[@"size"]=@(743*ret[@"name"].length/9),
        return(ret);
    }



WIFile<Treeable>
    NSSet treePropertyNames={ret=@[@"includes",@"ctxts"];}
    NSDictionary treeNodeData={ret=@{@"type":@"File"};}

WICtxt<Treeable>
    NSSet treePropertyNames={ret=@[@"clazzs",@"protocols"];}
    NSDictionary treeNodeData={ret=@{@"type":@"Context",@"name":[(id)self.keyInFile description]};}

WIClass<Treeable>
    NSSet treePropertyNames={ret=@[@"superclasss",@"conformedProtocols",@"superprotocols",@"varCtxts",@"types"];}
    NSDictionary treeNodeData={ret=@{
        @"type":@"Class",
        @"name":([(NSDictionary*)self.keyInClazz count]?
            [NSString stringWithFormat:@"%@{%@}",self.name,self.settings.description]:
            [NSString stringWithFormat:@"%@",self.name]
        )
    };}
    NSDictionary seenTreeNodeData={ret=@{@"type":@"Class",@"name":self.descriptiveName};}
    NSString descriptiveName={
        return([(NSDictionary*)self.context.keyInFile count]?
            self.settings.count?
                [NSString stringWithFormat:@"%@{%@} =>(%@)",self.name,self.settings.description,[(id)self.context.keyInFile description]]:
                [NSString stringWithFormat:@"%@ =>(%@)",self.name,[(id)self.context.keyInFile description]]
            ):
            ([(NSDictionary*)self.keyInClazz count]?
                [NSString stringWithFormat:@"%@{%@}",self.name,self.settings.description]:
                [NSString stringWithFormat:@"%@",self.name]
            )
        );
    }

WIVarContext<Treeable>
    NSSet treePropertyNames={ret=@[@"vars"];}
    NSDictionary treeNodeData={ret=@{@"type":@"VarContext",@"name":self.keyInClazz};}// TODO json
    NSDictionary seenTreeNodeData={ret=@{@"type":@"VarContext",@"name":self.descriptiveName};}
    NSString descriptiveName={
        return([(NSDictionary*)self.clazz.context.keyInFile count]?
            ([(NSDictionary*)self.keyInClazz count]?
                [NSString stringWithFormat:@"%@{%@} =>(%@)",self.clazz.name,[(id)self.keyInClazz description],[(id)self.clazz.context.keyInFile description]]:
                [NSString stringWithFormat:@"%@ =>(%@)",self.clazz.name,[(id)self.clazz.context.keyInFile description]]
            ):
            ([(NSDictionary*)self.keyInClazz count]?
                [NSString stringWithFormat:@"%@{%@}",self.clazz.name,[(id)self.keyInClazz description]]:
                [NSString stringWithFormat:@"%@",self.clazz.name]
            )
        );
    }

WIType<Treeable>
    NSSet treePropertyNames={ret=@[@"vars"];}
    NSDictionary treeNodeData={ret=@{@"type":@"Type",@"name":self.keyInClazz};}// TODO json
    NSDictionary seenTreeNodeData={ret=@{@"type":@"Type",@"name":self.descriptiveName};}
    NSString descriptiveName={
        return([(NSDictionary*)self.clazz.context.keyInFile count]?
            ([(NSArray*)self.keyInClazz count]?
                [NSString stringWithFormat:@"%@ %@ =>(%@)",self.clazz.name,[(id)self.keyInClazz description],[(id)self.clazz.context.keyInFile description]]:
                [NSString stringWithFormat:@"%@ =>(%@)",self.clazz.name,[(id)self.clazz.context.keyInFile description]]
            ):
            ([(NSArray*)self.keyInClazz count]?
                [NSString stringWithFormat:@"%@ %@",self.clazz.name,[(id)self.keyInClazz description]]:
                [NSString stringWithFormat:@"%@",self.clazz.name]
            )
        );
    }


WIVar<Treeable>
    NSSet treePropertyNames={ret=@[@"getter",@"setter",@"defaultValue",@"atomicVars"];}
    NSDictionary treeNodeData={ret=@{
        @"type":@"Var",
        @"name":[([(NSDictionary*)self.keyInClazz count]?
            [NSString stringWithFormat:@"%@{%@}",self.name,self.settings.description]:
            [NSString stringWithFormat:@"%@",self.name]
        )
        stringByAppendingFormat:self.boundTo?@" %@ %@":@"",
            self.bindingType,self.boundTo.descriptiveName]
    };}
    NSDictionary seenTreeNodeData={
        ret=@{@"type":@"Var",
            @"name":self.descriptiveName
        };
    }
    NSString descriptiveName={return([NSString stringWithFormat:@"%@::%@",self.context.descriptiveName,self.selectorString]);}
    NSString selectorString={
        NSMutableString *ret=[NSMutableString stringWithFormat:@"(%@)%@",self.type.descriptiveName,self.name];
        for (WIVarArg *arg in self.args) {
            [ret appendFormat:@"%@:(%@)%@",
                arg.arg?[@" " stringByAppendingString:arg.arg]:
                (arg.indexInVar?
                    @" ?":
                    @""
                ),
                arg.type.descriptiveName,
                arg.name?arg.name:@"?"
            ];
        }
        return(ret);
    }

WIBody<Treeable>
    NSSet treePropertyNames={ret=@[@"snippets"];}
    NSDictionary treeNodeData={ret=@{@"type":@"Body"};}

WIBodySnippet<Treeable>
    NSDictionary treeNodeData={
        ret=@{
            @"type":@"Snippet",
            @"name":[NSString stringWithFormat@"@%@: %@",[(id)self.keyInBody description],self.strings.description]
        };
    }







WIFile
    -(WICtxt*)contextWithRegexes:(NSDictionary*)regexes {
        WICtxt *ret=[self ctxtForKey:regexes];
        if (!ret) [self setCtxt:ret=[WICtxt new] forKey:regexes];
        return(ret);
    }

    -(void)process:(Token*)token regexes:(NSMutableDictionary*)regexes settings:(NSSet*)settings {
        Token *t=[TokenHelper actualToken:token];
        NSArray *chs;

        if ([TokenHelper actualToken:t havingRuleIn:@[@"class",@"protocol",@"classwprotocol",@"mod"]]) {
            [[self contextWithRegexes:@{}] process:token regexes:regexes.mutableCopy settings:settings outerClass:nil outerLinkType:nil outerLinkVar:nil mods:@[]];
        }
        else if ([TokenHelper actualToken:t havingRuleIn:@[@"regex"]]) {
            [regexes setObject:((Token*)t.children[1]).contents forKey:((Token*)t.children[0]).contents];
        }
        else if ((chs=[TokenHelper childrenForToken:t havingRuleIn:@[@"setting"]])) {
            NSString *setting=((Token*)t.children[0]).contents;
            if (!chs.count) {
                if (![self.includes containsObject:setting]) [self.includes addObject:setting];
            }
            else {
                for (Token *ch in chs) [self process:ch regexes:regexes settings:[settings setByAddingObject:setting]];
            }
        }
    }

WICtxt
    -(WIClass*)classWithName:(NSString*)name {
        WIClass *ret=[self clazzForKey:name];
        if (!ret) [self setClazz:ret=[WIClass new] forKey:name];
        return(ret);
    }
    -(WIClass*)protocolWithName:(NSString*)name {
        WIClass *ret=[self protocolForKey:name];
        if (!ret) [self setProtocol:ret=[WIClass new] forKey:name];
        return(ret);
    }

    -(void)process:(Token*)token regexes:(NSMutableDictionary*)regexes settings:(NSSet*)settings outerClass:(WIClass*)outerClass outerLinkType:(NSString*)outerLinkType outerLinkVar:(WIVar*)outerLinkVar mods:(NSArray*)mods {
        Token *t=[TokenHelper actualToken:token];
        NSArray *chs;
        bool doingInitialSettings=YES;

        if ((chs=[TokenHelper childrenForToken:t havingRuleIn:@[@"mod"]])) {
            NSMutableArray *newMods=@[].mutableCopy;
            for (Token *ch in chs) if (![TokenHelper actualToken:ch havingRuleIn:@[@"class",@"protocol",@"classwprotocol"]]) {
                [newMods addObject:ch.contents];
            }
            for (Token *ch in chs) if ([TokenHelper actualToken:ch havingRuleIn:@[@"class",@"protocol",@"classwprotocol"]]) {
                [self process:ch regexes:regexes settings:settings outerClass:outerClass outerLinkType:outerLinkType outerLinkVar:outerLinkVar mods:newMods];
            }
        }
        else if ((chs=[TokenHelper childrenForToken:t havingRuleIn:@[@"class"]])) {
            NSString *name=((Token*)t.children[0]).contents;
            NSString *sup=(t.children.count==1?nil:((Token*)t.children[1]).contents);
            WIClass *clazz=[self classWithName:name];
            if (sup) [clazz addSuperclass:[self classWithName:sup]];

            for (Token *ch in chs) [clazz process:ch regexes:regexes settings:settings doingInitialSettings:doingInitialSettings outerClass:outerClass outerLinkType:outerLinkType outerLinkVar:outerLinkVar mods:mods];
        }
        else if ((chs=[TokenHelper childrenForToken:t havingRuleIn:@[@"protocol"]])) {
            NSString *name=((Token*)t.children[0]).contents;
            WIClass *protocol=[self protocolWithName:name];
            int index=-1;
            for (Token *pt in t.children) if (++index) [protocol addSuperprotocol:[self protocolWithName:pt.contents]];

            for (Token *ch in chs) [protocol process:ch regexes:regexes settings:settings doingInitialSettings:doingInitialSettings outerClass:outerClass outerLinkType:outerLinkType outerLinkVar:outerLinkVar mods:mods];
        }
        else if ((chs=[TokenHelper childrenForToken:t havingRuleIn:@[@"classwprotocol"]])) {
            Token *classt=t.children[0];
            Token *protocolt=t.children[1];

            NSString *name=((Token*)classt.children[0]).contents;
            NSString *sup=(classt.children.count==1?nil:((Token*)classt.children[1]).contents);


            WIClass *clazz=[self classWithName:name];
            if (sup) [clazz addSuperclass:[self classWithName:sup]];
            for (Token *pt in protocolt.children) [clazz addConformedProtocol:[self protocolWithName:pt.contents]];

            for (Token *ch in chs) [clazz process:ch regexes:regexes settings:settings doingInitialSettings:doingInitialSettings outerClass:outerClass outerLinkType:outerLinkType outerLinkVar:outerLinkVar mods:mods];
        }
    }



WIClass
    -(WIVarContext*)varCtxtWithSettings:(NSSet*)settings {
        WIVarContext *ret=[self varCtxtForKey:settings];
        if (!ret) [self setVarCtxt:ret=[WIVarContext new] forKey:settings];
        return(ret);
    }
    -(WIType*)typeWithModifiers:(NSArray*)mods {
        WIType *ret=[self typeForKey:mods];
        if (!ret) [self setType:ret=[WIType new] forKey:mods];
        return(ret);
    }

    WICtxt context={return(self.classInCtxt?self.classInCtxt:self.protocolInCtxt);}
    NSString name={return(NSString*)(self.classInCtxt?self.keyInClassInCtxt:self.keyInProtocolInCtxt);}

    -(void)process:(Token*)token regexes:(NSMutableDictionary*)regexes settings:(NSSet*)settings doingInitialSettings:(bool&)doingInitialSettings outerClass:(WIClass*)outerClass outerLinkType:(NSString*)outerLinkType outerLinkVar:(WIVar*)outerLinkVar mods:(NSArray*)mods {
        Token *t=[TokenHelper actualToken:token];
        NSArray *chs;

        if ((chs=[TokenHelper childrenForToken:t havingRuleIn:@[@"setting"]])) {
            if (doingInitialSettings&&[TokenHelper isJustSetting:token]) {
                [TokenHelper settingDictionaryForToken:token addTo:self.settings];
            }
            else {
                NSSet *newSettings=[settings setByAddingObject:((Token*)t.children[0]).contents];
                doingInitialSettings=NO;
                for (Token *ch in chs) [self process:ch regexes:regexes settings:newSettings doingInitialSettings:doingInitialSettings outerClass:outerClass outerLinkType:outerLinkType outerLinkVar:outerLinkVar mods:mods];
            }
        }
        else if ([TokenHelper actualToken:t havingRuleIn:@[@"class",@"protocol",@"classwprotocol",@"mod"]]) {
            [[self.context.file contextWithRegexes:regexes] process:token regexes:regexes.mutableCopy settings:settings outerClass:self outerLinkType:nil outerLinkVar:nil mods:@[]];
        }
        else if ([TokenHelper actualToken:t havingRuleIn:@[@"regex"]]) {
            [regexes setObject:((Token*)t.children[1]).contents forKey:((Token*)t.children[0]).contents];
        }
        else if (outerClass&&((chs=[TokenHelper childrenForToken:t havingRuleIn:@[@"var",@"fn"]]))) {
            WIVarContext *varCtxt=[outerClass varCtxtWithSettings:settings];
            WIVar *var=[varCtxt varForVarToken:t type:[self typeWithModifiers:mods] regexes:regexes];

            bool varDoingInitialSettings=YES;
            NSMutableDictionary *newRegexes=regexes.mutableCopy;
            for (Token *ch in chs) {
                [var process:ch regexes:newRegexes settings:settings doingInitialSettings:varDoingInitialSettings];
            }
        }
    }

WIVarContext
    -(WIVar*)varForVarToken:(Token*)token type:(WIType*)type regexes:(NSMutableDictionary*)regexes {
        NSString *name=((Token*)token.children[0]).contents;
        NSMutableArray *key=@[
            name,
            type.clazz.classInCtxt?type.clazz.name:NSNull.null,
            type.clazz.protocolInCtxt?@[type.clazz.name]:NSNull.null,
            type.keyInClazz
        ].mutableCopy;
        NSMutableArray *argTypes=@[].mutableCopy,*argArgs=@[].mutableCopy,*argNames=@[].mutableCopy;
        for (Token *ch in token.children) {
            int nameArg=-1,argArg=-1,typeArg=-1;
            if ([ch.ruleName isEqualToString:@"selArgDef"]) {
                switch (ch.children.count) {
                    case 1: argArg=-1;nameArg=-1;typeArg=0;break;
                    case 2: argArg=-1;nameArg=1;typeArg=0;break;
                    case 3: argArg=0;nameArg=2;typeArg=1;break;
                }
            }
            else if ([ch.ruleName isEqualToString:@"argDef"]) {
                switch (ch.children.count) {
                    case 1: argArg=-1;nameArg=-1;typeArg=0;break;
                    case 2: argArg=-1;nameArg=1;typeArg=0;break;
                }
            }

            NSString *name=(nameArg==-1?nil:((Token*)ch.children[nameArg]).contents);
            NSString *arg=(argArg==-1?nil:((Token*)ch.children[argArg]).contents);

            Token *typet=ch.children[typeArg],*classt=typet;
            NSMutableArray *mods=@[].mutableCopy;
            if ([typet.ruleName isEqualToString:@"mod"]) {
                for (Token *ch2 in typet.children) if (![TokenHelper actualToken:ch havingRuleIn:@[@"class",@"protocol",@"classwprotocol"]]) {
                    [mods addObject:ch2.contents];
                }
                else classt=typet;
            }
            WICtxt *ctxt=[self.clazz.context.file contextWithRegexes:regexes];
            NSString *className=nil,*protocolName=nil;
            if ([classt.ruleName isEqualToString:@"class"]) className=((Token*)classt.children[0]).contents;
            else if ([classt.ruleName isEqualToString:@"classwprotocol"]) className=((Token*)((Token*)classt.children[0]).children[0]).contents;
            else if ([classt.ruleName isEqualToString:@"protocol"]) protocolName=((Token*)classt.children[0]).contents;

            WIClass *clazz=(className?[ctxt classWithName:className]:[ctxt protocolWithName:protocolName]);
            WIType *argType=[clazz typeWithModifiers:mods];

            [key addObject:@[
                name?name:NSNull.null,
                arg?arg:NSNull.null,
                className?className:NSNull.null,
                protocolName?@[protocolName]:NSNull.null,// TODO
                mods
            ]];

            [argTypes addObject:argType];
            [argNames addObject:name?name:NSNull.null];
            [argArgs addObject:arg?arg:NSNull.null];
        }

        WIVar *var=[self varForKey:key];
        if (!var) {
            [self setVar:var=[WIVar new] forKey:key];
            var.type=type;
            var.name=name;
            for (int i=0;i<argTypes.count;i++) {
                WIVarArg *arg=[WIVarArg new];
                arg.type=argTypes[i];
                if ([argNames[i] isKindOfClass:NSString.class]) arg.name=argNames[i];
                if ([argArgs[i] isKindOfClass:NSString.class]) arg.arg=argArgs[i];
                [var addArg:arg];
            }
        }
        return(var);
    }



WIVar
    -(void)process:(Token*)token regexes:(NSMutableDictionary*)regexes settings:(NSSet*)settings doingInitialSettings:(bool&)doingInitialSettings {
        Token *t=[TokenHelper actualToken:token];
        NSArray *chs;

        if ((chs=[TokenHelper childrenForToken:t havingRuleIn:@[@"setting"]])) {
            if (doingInitialSettings&&[TokenHelper isJustSetting:token]) {
                [TokenHelper settingDictionaryForToken:token addTo:self.settings];
            }
            else {
                NSSet *newSettings=[settings setByAddingObject:((Token*)t.children[0]).contents];
                doingInitialSettings=NO;
                for (Token *ch in chs) [self process:ch regexes:regexes settings:newSettings doingInitialSettings:doingInitialSettings];
            }
        }
        else if ([TokenHelper actualToken:t havingRuleIn:@[@"block"]]) {
            WIBody *body=self.getter;
            if (!body) self.getter=body=[WIBody new];
            [body incorporateBody:((Token*)t.children[0]).contents];
        }
        else if ((chs=[TokenHelper childrenForToken:t havingRuleIn:@[@"getter"]])) {
            WIBody *body=self.getter;
            if (!body) self.getter=body=[WIBody new];
            [body incorporateBody:((Token*)((Token*)chs[0]).children[0]).contents];
        }
        else if ((chs=[TokenHelper childrenForToken:t havingRuleIn:@[@"init"]])) {
            WIBody *body=self.defaultValue;
            if (!body) self.defaultValue=body=[WIBody new];
            [body incorporateBody:((Token*)((Token*)chs[0]).children[0]).contents];
        }
        else if ((chs=[TokenHelper childrenForToken:t havingRuleIn:@[@"setter"]])) {
            NSString *setterVar=(t.children.count?((Token*)t.children[0]).contents:@"v");
            WIBody *body=[self setterForKey:setterVar];
            if (!body) [self setSetter:body=[WIBody new] forKey:setterVar];
            [body incorporateBody:((Token*)((Token*)chs[0]).children[0]).contents];
        }
        else if ([TokenHelper actualToken:t havingRuleIn:@[@"regex"]]) {
            [regexes setObject:((Token*)t.children[1]).contents forKey:((Token*)t.children[0]).contents];
        }
        else if ((chs=[TokenHelper childrenForToken:t havingRuleIn:@[@"link"]])) {
            NSString *linkType=((Token*)t.children[0]).contents;
            WICtxt *ctxt=[self.context.clazz.context.file contextWithRegexes:regexes];
            NSMutableDictionary *newRegexes=regexes.mutableCopy;
            for (Token *ch in chs) {
                [ctxt process:ch regexes:newRegexes settings:settings outerClass:nil outerLinkType:linkType outerLinkVar:self mods:@[]];
            }
        }
        else if ((chs=[TokenHelper childrenForToken:t havingRuleIn:@[@"atomic"]])) {
            WIVarContext *varCtxt=[[[self.context.clazz.context.file contextWithRegexes:regexes] classWithName:self.context.clazz.name] varCtxtWithSettings:settings];
            NSMutableDictionary *newRegexes=regexes.mutableCopy;
            for (Token *ch in chs) {
                [self addAtomicVar:[varCtxt varForVarToken:ch type:self.type regexes:newRegexes]];
            }
        }
    }


WIBody
    -(WIBodySnippet*)snippetAtOrdinal:(int)ordinal {
        WIBodySnippet *ret=[self snippetForKey:@(ordinal)];
        if (!ret) [self setSnippet:ret=[WIBodySnippet new] forKey:@(ordinal)];
        return(ret);
    }

    +(NSRegularExpression*)splitterRegex {
        static NSRegularExpression *ret;
        NSError *err=nil;
        if (!ret) ret=[NSRegularExpression regularExpressionWithPattern:@"((?:[^\"@]*(?:\"(\\\\\\\\|\\\\\"|[^\"])++\")?)*+)@((?:-?\\d+)?)" options:NSRegularExpressionDotMatchesLineSeparators error:&err];
        return(ret);
    }
    -(void)incorporateBody:(NSString*)body {
        NSArray *matches=[self.class.splitterRegex matchesInString:body options:0 range:NSMakeRange(0,body.length)];
        WIBodySnippet *snippet=nil;
        int at=0;
        for (NSTextCheckingResult *match in matches) {
            NSString *s=[body substringWithRange:[match rangeAtIndex:1]];
            if (snippet||s.length) {
                if (!snippet) snippet=[self snippetAtOrdinal:at];
                [snippet.strings addObject:s];
            }
            if ([match rangeAtIndex:2].length) {
                at=[body substringWithRange:[match rangeAtIndex:2]].intValue;
                snippet=[self snippetAtOrdinal:at];
            }
        }
    }






